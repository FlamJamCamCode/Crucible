{
  "name": "Better Windows 11",
  "uuid": "0198188d-628c-76df-834c-c13c8e8c55d8",
  "description": "We are making several tools that make the windows 11 experience better.\n\n1) Window manager. Panel/Taskbar and navigation. We'll aim for the option to control everything easily with keyboards.\n2) Windows multi-seat input router: device-specific keyboard/mouse mapping, per-application profiles, enabling multiple users on one PC with separate peripherals.\n3) Concurrency control to make \"single program utility\" efficient. Drown out the many tasks that are always running in easy ways.",
  "created_at": "2025-07-17T13:22:55.763557+00:00",
  "updated_at": "2025-07-17T13:30:46.314963+00:00",
  "is_private": true,
  "is_starter_project": false,
  "creator": {
    "uuid": "db6ec333-f39a-4a29-81d9-dc1e2adbe2bc",
    "full_name": "MagMaM"
  },
  "docs": [
    {
      "uuid": "096541fc-d93a-439d-9437-9d2e1486c503",
      "filename": "Windows 11 Power Tools: A Manifesto for Input Liberation and System Control.md",
      "content": "# Windows 11 Power Tools: A Manifesto for Input Liberation and System Control\n\n## Executive Summary\n\nThis document outlines a revolutionary suite of tools designed to transform Windows 11 from a single-user, rigidly-controlled operating system into a flexible, multi-user, power-user paradise. Through three interconnected but independent components\u2014a Vim-inspired Window Manager, a Universal Input Router, and a Visual Concurrency Control system\u2014we liberate computing from decades-old paradigms.\n\nThe core philosophy: **Every assumption about how we interact with computers is just a historical accident waiting to be questioned.**\n\nMost remarkably, this software solution effectively transforms one physical computer into multiple independent workstations\u2014each with its own keyboard, mouse, and monitor(s)\u2014without virtualization overhead. A single powerful PC can serve an entire family, classroom, or office as if it were multiple separate computers.\n\n---\n\n## Table of Contents\n\n1. [Vision: Computing Unchained](#vision-computing-unchained)\n2. [Component 1: The Window Manager Revolution](#component-1-the-window-manager-revolution)\n3. [Component 2: Universal Input Router](#component-2-universal-input-router)\n4. [Component 3: Living Priority Graph](#component-3-living-priority-graph)\n5. [Integration Philosophy](#integration-philosophy)\n6. [Technical Architecture](#technical-architecture)\n7. [Revolutionary Use Cases](#revolutionary-use-cases)\n8. [Implementation Roadmap](#implementation-roadmap)\n\n---\n\n## Vision: Computing Unchained\n\n### The Problem Space\n\nModern operating systems trap us in assumptions from the 1980s:\n- One keyboard, one mouse, one user\n- Only Ctrl, Alt, Shift, and Win are \"modifiers\"\n- Input goes to one program at a time\n- Process priority is invisible and immutable\n- Window management is mouse-centric\n- Every program reinvents text editing\n\n### The Solution Space\n\nWe propose a radical reimagining where:\n- Any number of input devices serve any number of users on one machine\n- Every key can be a modifier, every rhythm a command\n- Input streams fork, merge, and transform freely\n- Process priority is a living, visual, interactive system\n- Navigation is modal, efficient, and consistent everywhere\n- The OS provides a universal text interaction layer\n\n---\n\n## Component 1: The Window Manager Revolution\n\n### Core Concept: Universal Vim-like Navigation\n\nInstead of fighting with each application's unique interface, we intercept at the presentation layer\u2014where text becomes pixels\u2014and provide universal navigation.\n\n### The Font Layer Interception\n\n```\nApplication renders text \u2192 Font/DirectX layer \u2192 We intercept here \u2192 Screen\n                                                         \u2193\n                                              Build spatial map of jumpable targets\n```\n\nThis isn't about parsing application logic. It's about seeing what the user sees and making it navigable.\n\n### Key Innovations\n\n#### 1. Temporal Commands\nTraditional: `Ctrl+Shift+Alt+F12` (finger gymnastics)  \nOurs: `\\\\` within 50ms (temporal leader key)\n\n- `\\\\` \u2192 Command palette\n- `\\a` \u2192 Switch keyboard layout  \n- `\\\\\\` \u2192 Window switcher\n- Temporal patterns expand input vocabulary without physical keys\n\n#### 2. Universal Text Objects\nLike a system-wide vim mode that works EVERYWHERE:\n- `%` jumps between matching brackets (in ANY program)\n- `ciw` changes inner word (in Notepad, Word, browsers)\n- `dd` deletes line (universally)\n\n#### 3. Implementation Layers\n1. **Text Services Framework (TSF)**: Official Windows API approach\n2. **Rendering Hooks**: DirectWrite/GDI interception for universal coverage\n3. **Accessibility APIs**: UI Automation for application-specific enhancement\n4. **Input Method Editor Model**: System-wide vim as an IME\n\n### Beyond i3: Tiling for Windows\n\nWhile i3 brought tiling to Linux, our approach goes further:\n- Vim-like bindings by default (`hjkl` for navigation)\n- Temporal commands for window manipulation\n- Device-specific focus (keyboard 2 only controls windows on monitor 7)\n- The window manager itself is just another program that receives routed input\n\n---\n\n## Component 2: Universal Input Router\n\n### Core Philosophy: Simple Pipes, Infinite Possibilities\n\n```\nRaw Device Event \u2192 Router (where?) \u2192 Mapper (what?) \u2192 Program\n```\n\nThe router is a dumb pipe. It knows nothing about what inputs mean, only where they go.\n\n### The Architecture\n\n```\nDevice ID: 0x1234, ScanCode: 0x24, State: Down\n              \u2193\n         [ROUTER RULES]\n         \u251c\u2192 Active Window (exclusive)\n         \u251c\u2192 Background Daemon (always listening)\n         \u2514\u2192 Specific Program (targeted)\n              \u2193\n    [MAPPER SELECTION PER PROGRAM]\n    \u251c\u2192 Raw Events (no interpretation)\n    \u251c\u2192 Vim Mode (navigation commands)\n    \u251c\u2192 Media Controls (targeted player control)\n    \u251c\u2192 Gaming (low-latency, focus-independent)\n    \u251c\u2192 Custom Rhythmic (pattern detection)\n    \u2514\u2192 Language-Aware (context-sensitive)\n```\n\n#### The Multilingual Revolution\n\nFor bi/tri-lingual users, the mapper system eliminates constant layout switching:\n\n**Automatic Language Mapping**\n```\nFocus: WhatsApp \u2192 Mapper: Sanskrit layout\nFocus: Slack #danish-team \u2192 Mapper: Danish layout  \nFocus: Academic Paper \u2192 Mapper: Greek symbols\nFocus: Code Editor \u2192 Mapper: US English\n```\n\n**Intelligent Context Detection**\n- Program title language detection\n- Active conversation language analysis\n- Contact/channel-based switching\n- Historical usage patterns\n\n**Multi-Layout Streaming**\n```\nScanCode: 0x24 \u2192 Mapper sends:\n\u251c\u2192 Sanskrit: \u0915\n\u251c\u2192 Danish: j  \n\u2514\u2192 Greek: \u03be\n\nProgram's intellisense chooses based on context\n```\n\nThe program receives multiple interpretations and picks the most sensible one based on what's being typed. No more \"\u0393\u03b5\u03b9\u03b1 \u03c3\u03bf\u03c5\" appearing as \"Geia sou\" because you forgot to switch layouts!\n\n#### Advanced Media Control Mapping\n\nThe media mapper solves the \"which player?\" problem:\n\n**Traditional OS Limitation**\n```\nPlay button \u2192 OS decides \u2192 Usually wrong program\n```\n\n**Our Approach: Targeted Control**\n```\nFoot Pedal + \\\\ytp \u2192 YouTube Player 1 (pause/play)\nFoot Pedal + \\\\yt2p \u2192 YouTube Player 2 (pause/play)\nKeyboard 2 \u2192 Always controls music player\nGaming mouse side buttons \u2192 Video editor timeline\n```\n\n**Temporal Media Commands**\n- `\\\\ytp` = YouTube play/pause\n- `\\\\spp` = Spotify play/pause  \n- `\\\\vlc` = VLC control mode\n- `\\\\med` = Cycle through media players\n\nNo more \"OS thinks THIS is the active media player\" frustration!\n\n#### Gaming Mapper: Beyond WASD\n\nThe gaming mapper isn't about key layouts\u2014it's about performance and focus:\n\n**Direct Input Path**\n```\nNormal: Device \u2192 OS \u2192 Window Manager \u2192 Focused Window \u2192 Game\nGaming: Device \u2192 Router \u2192 Gaming Mapper \u2192 Game (direct)\n```\n\n**Key Benefits**\n- **Bypasses window manager**: No focus loss during gameplay\n- **Reduced latency**: Skips OS input processing layers\n- **Focus independence**: Alt-tab won't interrupt your game\n- **Exclusive device access**: That gaming mouse ONLY controls the game\n\n**Creative Uses**\n- Racing wheel always controls racing game (even when checking Discord)\n- Flight stick maintains control during streaming software interaction\n- Foot pedals for push-to-talk that work regardless of focus\n\n### Understanding Mappers vs Command Programs\n\n**Critical Distinction**: \n- **Mappers** = Input transformers that wrap programs\n- **Command Programs** = Receivers of raw input that trigger actions\n\nExample architecture:\n```\nFoot Pedal \u2192 Router \u2192 Vim Mapper \u2192 Notepad\n                           \u2193\n                   Notepad now has vim bindings!\n\nAll Devices \u2192 Router \u2192 Raw Events \u2192 \"Muh Spezhul Commandors\"\n                                            \u2193\n                                    Watches for complex patterns\n                                    across all devices\n```\n\n### The Universal Snippet Revolution\n\nTraditional: Every program has different snippet systems\nOur approach: One mapper provides snippets everywhere\n\n```\nYou type: \"forr\"\n           \u2193\nContext-Aware Mapper expands:\n\u251c\u2192 Python: for i in range(|):\n\u251c\u2192 JavaScript: for (let i = 0; i < |; i++)\n\u251c\u2192 C++: for (int i = 0; i < |; ++i)\n\u251c\u2192 Email: \"For reference, please see\"\n\u2514\u2192 Bash: for file in *; do | done\n```\n\n**Temporal Command Composition**\n```\n\\\\forr \u2192 Waits for temporal input...\n\u251c\u2192 [timeout] \u2192 Simple expansion\n\u251c\u2192 \\\\if \u2192 Nested structure (for + if)\n\u251c\u2192 10 \u2192 Parameterized (for i < 10)\n\u2514\u2192 {custom} \u2192 Complex patterns\n```\n\n### Creating New Symbolic Languages\n\nThe mapper system accidentally enables million-symbol languages:\n\n**Input Combinations**\n- **Chords**: 10 keys = 1,023 combinations\n- **Sequences**: Order matters (ab \u2260 ba)\n- **Rhythms**: Timing creates meaning\n- **Cross-device**: Foot + hand + keyboard\n\n**Real Applications**\n```\nChord J+K+L \u2192 \u27e8entire function template\u27e9\nFoot rhythm \u2192 \u27e8chemical structure\u27e9\nDevice combo \u2192 \u27e8mathematical proof\u27e9\n```\n\nProfessional domains get their own symbolic systems:\n- Law: Contract clauses as symbols\n- Medicine: Diagnostic patterns as glyphs\n- Music: Chord progressions as single inputs\n- Architecture: Building elements as symbols\n\n### Context Discovery Methods\n\nMappers determine context through three methods:\n\n1. **Program Hints**\n   ```\n   Program says: \"I'm editing main.py\"\n   Mapper uses: Python snippets\n   ```\n\n2. **Font Layer Intelligence**\n   ```\n   Mapper sees rendered text\n   Detects: Language, syntax, context\n   Adjusts: Completions and expansions\n   ```\n\n3. **Historical Patterns**\n   ```\n   This window usually = Python\n   This time of day = Email writing\n   This monitor = Documentation\n   ```\n\n### The Wrapper Architecture\n\nAny program becomes powerful through wrapping:\n\n```\nDiscord doesn't have vim mode?\nDevice \u2192 Router \u2192 Vim Mapper \u2192 Discord\n                      \u2193\n              Now it does!\n\nNotepad lacks snippets?\nDevice \u2192 Router \u2192 Snippet Mapper \u2192 Notepad\n                        \u2193\n                Now it has them!\n```\n\n**One implementation, everywhere**:\n- No more VSCode vim plugin\n- No more Chrome vim extension\n- No more Outlook vim addon\n- Just system-level vim that works identically everywhere\n\n### Revolutionary Concepts\n\n#### 1. Every Key as Modifier\nAt the OS level, not as a hack:\n- `A (held) + B` = distinct from `A then B`\n- `J+K+L` = three-key chord\n- No special \"modifier\" keys\u2014ANY key can modify\n\n#### 2. Rhythmic Commands\nBeyond Morse code to actual rhythm:\n```\nFoot: kick\u2500\u2500\u2500\u2500\u2500kick\u2500\u2500\u2500\u2500\u2500\nHand: \u2500\u2500\u2500\u2500clap\u2500\u2500\u2500\u2500\u2500clap\u2500\n      \u2193\n  \"Rock beat\" = Launch application\n```\n\nNot just duration but timing, groove, syncopation.\n\n#### 3. Cross-Device Patterns\n```\nKeyboard1: tap\u2500\u2500\u2500\u2500\u2500tap\u2500\u2500\u2500\u2500\u2500\nKeyboard2: \u2500\u2500\u2500tap\u2500\u2500\u2500\u2500\u2500tap\u2500\u2500\n           \u2193\n     \"Duet authorization\"\n```\n\nMultiple devices creating unified commands.\n\n#### 4. Modal Device and Mapper Switching\nAny device can dynamically change both its routing AND its mapper:\n\n**Program Cycling**\n- Foot pedals: `\\\\` \u2192 cycle through target programs\n- `\\\\` \u2192 VS Code \u2192 Spotify \u2192 Discord \u2192 VS Code...\n\n**Mapper Cycling Within Program**\n- Foot pedals: `\\\\\\` \u2192 cycle through mappers for current program\n- `\\\\\\` \u2192 vim mode \u2192 raw input \u2192 Danish layout \u2192 Greek layout...\n\n**Control Methods**\n- Temporal commands: `\\\\` patterns\n- Context menu: Right-click on any input field \u2192 Select Input Mapper\n- System tray: Quick mapper switching UI\n- IPC commands: `router-cmd \"set-mapper device:kb1 program:vscode mapper:vim\"`\n\nEach device remembers its last mapper per program, creating a personalized input matrix.\n\n#### 5. Automatic Language Context\nThe mapper system solves the multilingual user's nightmare:\n- No more forgetting to switch keyboard layouts\n- Per-program automatic language selection\n- Multi-interpretation streaming for smart programs\n- Context-aware switching (per contact, per channel, per document)\n\nFinally, your computer speaks all your languages and knows when to use each one.\n\n#### 6. Universal Snippet Expansion\nOne mapper provides consistent snippets across all programs:\n- Same abbreviations work everywhere\n- Context-aware expansions\n- Temporal composition of commands\n- Share snippet libraries like dotfiles\n\n#### 7. Million-Symbol Languages\nEscape keyboard limitations entirely:\n- Chord combinations create thousands of symbols\n- Rhythmic patterns add temporal meaning\n- Cross-device combos enable complex glyphs\n- Professional domains get custom symbol systems\n\n### Use Case: The Multi-User Single-PC Revolution\n\n```\nDad's Setup:  Keyboard1 + Mouse1 \u2192 Work apps on Monitors 1-3\nKid's Setup:  Keyboard2 + Mouse2 \u2192 Games on Monitor 4\nMusic Setup:  Keyboard3 \u2192 Always routes to DAW as MIDI\nFoot Pedals:  Universal \u2192 Context-aware commands\n```\n\nAll on one powerful PC. No virtualization. No remote desktop. Just intelligent routing.\n\n---\n\n## Component 3: Living Priority Graph\n\n### The Problem with Traditional Scheduling\n\n- Priority is invisible\n- Priority inversion is \"solved\" with rigid rules\n- Users have no real control\n- Background tasks can starve or hog resources\n\n### Our Solution: Physics-Based Visual Priority\n\nProcess priority becomes a living, breathing graph where:\n- Nodes = Processes/Threads\n- Edges = Dependencies/Blocks\n- Physics = User-defined rules\n\n### Physics Models as Scheduling Policies\n\n#### Solar System Mode\n```\nCritical Task = Sun (massive gravity)\nOther tasks = Planets\n- Blocking the sun pulls everything up\n- \"Nothing else matters\" mode\n```\n\n#### Spring Network Mode\n```\nAll tasks connected by springs\n- Blocking creates tension\n- Natural oscillation and settling\n- Self-balancing system\n```\n\n#### Quantum Mode\n```\nLow priority can \"tunnel\" to high\n- Prevents starvation\n- Controlled chaos\n- Background tasks eventually run\n```\n\n### Visual Interaction\n\n- **Drag nodes** to manually adjust priority\n- **See edges form** when tasks block each other\n- **Watch the physics** as the system rebalances\n- **Save configurations** as \"modes\" (Gaming, Work, Rendering)\n\n### Priority Inheritance Solved Visually\n\nTraditional: Automatic priority inheritance with fixed rules  \nOurs: SEE the problem forming, DECIDE how to respond\n\n```\nHigh Priority A \u2192 (blocked on) \u2192 Low Priority B\n                \u2193\n         Edge grows stronger\n                \u2193\n    Visual tension pulls B upward\n                \u2193\n    User can intervene or let physics handle it\n```\n\n---\n\n## Integration Philosophy\n\n### Unix Philosophy for Windows\n\nEach component does ONE thing well:\n- **Router**: Routes input streams\n- **Mapper**: Interprets events  \n- **Window Manager**: Manages windows\n- **Priority Graph**: Visualizes scheduling\n\n### Composability\n\n```\nFoot Pedal \u2192 Router \u2192 Window Manager \u2192 Switch Desktop\n                  \u2193\n           Also routes to\n                  \u2193\n        Rhythm Detector \u2192 Launch Programs\n```\n\n### No Special Cases\n\n- The window manager is just another program\n- Every device is just an input stream\n- Every program can receive from any device\n- Every interaction is just physics\n\n---\n\n## Technical Architecture\n\n### Layer 1: Kernel Driver (Input Interception)\n\n```c\n// Pseudo-code for driver layer\nDeviceEvent event = InterceptHardwareInterrupt();\nRouteEvent(event.DeviceID, event.Data);\n```\n\n- Signed driver for Windows\n- Minimal processing in kernel space\n- Fast path to userspace router\n\n### Layer 2: Userspace Router Service\n\n```rust\n// Routing rules engine\nmatch (device_id, current_rules) {\n    (0x1234, Rules::Exclusive(prog)) => send_to(prog),\n    (0x1234, Rules::Multicast(progs)) => broadcast_to(progs),\n    _ => send_to(focused_window())\n}\n```\n\n### Layer 3: Per-Program Mappers\n\n```javascript\n// Example mapper for rhythm detection\nconst pattern = detectRhythm(eventStream);\nif (pattern.matches(\"kick-snare-kick-kick-snare\")) {\n    emit(\"SWITCH_DESKTOP\");\n}\n```\n\n```javascript\n// Media mapper with targeted control\nconst mediaMapper = {\n    temporalCommands: {\n        \"\\\\\\\\ytp\": \"youtube_player_1\",\n        \"\\\\\\\\yt2p\": \"youtube_player_2\", \n        \"\\\\\\\\spp\": \"spotify\",\n        \"\\\\\\\\vlc\": \"vlc_player\"\n    },\n    \n    route: function(event, command) {\n        const target = this.temporalCommands[command];\n        if (target) {\n            sendToProgram(target, event);\n        } else {\n            // Fallback to OS media keys\n            sendToOS(event);\n        }\n    }\n};\n```\n\n```cpp\n// Gaming mapper bypassing window manager\nvoid gamingMapperRoute(InputEvent event) {\n    // Skip OS input queue entirely\n    HANDLE gameProcess = getGameHandle();\n    \n    // Direct injection into game's input buffer\n    injectInput(gameProcess, event);\n    \n    // No window focus required\n    // No OS processing latency\n    // No alt-tab interruption\n}\n```\n\n### Layer 4: Font/Rendering Hooks\n\n```cpp\n// DirectWrite hook for universal navigation\nIDWriteTextLayout* layout = GetCurrentLayout();\nBuildSpatialMap(layout);\nRegisterJumpTargets(map);\n```\n\n### Layer 5: Window Manager Modes\n\n```rust\n// Window manager handling multi-user scenarios\nenum WindowManagerMode {\n    // Each user confined to their monitors\n    Isolated { \n        user_zones: HashMap<DeviceID, MonitorSet>,\n        mouse_confinement: true,\n        focus_isolation: true\n    },\n    \n    // Users can selectively share screens\n    Collaborative {\n        shared_windows: Vec<WindowID>,\n        input_merge_rules: MergePolicy\n    },\n    \n    // Traditional single-user mode\n    Unified {\n        all_devices_global: true\n    }\n}\n\n// Dynamic switching based on context\nmatch current_mode {\n    Isolated => each_user_owns_their_space(),\n    Collaborative => enable_selective_sharing(),\n    Unified => traditional_desktop()\n}\n```\n\n---\n\n## Revolutionary Use Cases\n\n### The Living Room PC\n- Monitor 1: Dad working with keyboard/mouse 1\n- Monitor 2: Kid gaming with keyboard/mouse 2  \n- Monitor 3: Mom browsing with keyboard/mouse 3\n- All one PC, no conflicts, perfect isolation\n\n### The Economic Revolution: One Computer, Many Users\nTransforming one powerful PC into multiple independent workstations:\n```\nTraditional: Need 4 computers for 4 family members = $4000\nOur solution: 1 good PC ($1000) + 4 keyboards ($100) + 4 monitors ($400)\nTotal: $1500 - SAVES $2500\n\nEach user gets:\n- Their own monitor with confined mouse movement\n- Their own keyboard with independent focus\n- Full performance (no VM overhead)\n- Complete isolation (can't interfere with others)\n\nWindow Manager modes:\n\u251c\u2192 Confined mode: Mouse trapped to assigned monitors\n\u251c\u2192 Shared mode: Specific devices can cross boundaries\n\u2514\u2192 Collaborative mode: Selective screen sharing\n```\n\nPoor families, schools, and community centers can provide computing for many with the hardware cost of one.\n\n### The Music Producer's Dream\n- Main keyboard: Normal typing\n- Second keyboard: Permanently mapped as MIDI controller\n- Foot pedals: Transport controls (play/pause/record)\n- Knob controller: Always controls mixer\n- No mode switching, no configuration\u2014each device has its purpose\n\n### The Multi-Media Power User\nManaging multiple media streams simultaneously:\n```\nCurrent Setup:\n- YouTube tutorial (monitor 1)\n- YouTube music (monitor 3)  \n- Spotify (background)\n- Video editor (monitor 2)\n- Music DAW (monitor 4)\n\nDevice Mapping:\n- Foot left: \\\\ytp \u2192 YouTube tutorial play/pause\n- Foot right: \\\\ytm \u2192 YouTube music play/pause\n- Keyboard 2 media keys \u2192 Spotify\n- Shuttle wheel \u2192 Video editor scrubbing\n- MIDI controller \u2192 DAW transport\n\nNever again: \"Which player did the OS pause?!\"\n```\n\n### The Accessibility Revolution\n- Limited mobility user with 2-button device achieves full control through rhythm patterns\n- Foot pedals for users who can't use hands effectively\n- Eye tracker + foot pedal combinations\n- Custom devices mapped exactly to user needs\n\n### The Next-Gen Multitasker\nUsing novel input devices for parallel control:\n```\nSetup:\n- Eye tracker \u2192 Window focus switching\n- Primary keyboard \u2192 Current focused window\n- Gaming keypad (left hand) \u2192 Always controls game\n- Drawing tablet \u2192 Always controls Photoshop\n- Foot pedals \u2192 Media control across all apps\n\nWorkflow:\n1. Look at OBS \u2192 Primary keyboard now types there\n2. Left hand continues gaming uninterrupted\n3. Right hand sketches on tablet in Photoshop\n4. Foot taps to pause tutorial video\n5. Look back at game \u2192 Primary keyboard switches to game chat\n\nALL SIMULTANEOUSLY. No Alt-Tab. No focus loss. No interruption.\n```\n\n### The Power Programmer's Paradise\n- Primary keyboard: Coding\n- Secondary keyboard: Macros and shortcuts\n- Foot pedals: Build, run, debug\n- Stream deck: Project switching\n- All devices work in parallel, no context switching\n\n### The Streamer's Setup\nGaming while multitasking - TRULY SIMULTANEOUSLY:\n```\nGaming mouse/keyboard \u2192 Direct to game (never loses focus)\nSecondary keyboard \u2192 OBS scene switching AND chat typing\nStream deck \u2192 Chat commands and alerts\nFoot pedals \u2192 Push-to-talk (works even when tabbed out)\n\nRevolutionary capability:\n- LEFT HAND: Playing the game (WASD movement)\n- RIGHT HAND: Typing in OBS chat simultaneously\n- FOOT: Switching between game audio and mic audio\n- No focus switching, no interruption, TRUE parallel control\n\nOr with foot pedal: tap to switch which keyboard controls which program\nAll while the game continues receiving input from gaming devices\n```\n\n### The Collaborative Workspace\n```\nTwo programmers, one computer:\n- Keyboard 1 + Keyboard 2 \u2192 Same editor\n- Multiple cursors like Google Docs\n- Rhythm patterns for \"handoff\" \n- Visual priority shows whose process is running\n```\n\n### The Polyglot's Paradise\nA translator working across multiple languages:\n```\nMorning workflow:\n- Email (Greek) \u2192 Keyboard auto-maps to Greek\n- Slack #denmark \u2192 Keyboard auto-maps to Danish\n- Sacred texts app \u2192 Keyboard auto-maps to Sanskrit\n- VS Code \u2192 Keyboard returns to English\n\nZero manual switching. The computer knows your context.\n```\n\nOr even smarter - the mapper sends all possible interpretations:\n```\nYou type: ScanCode pattern for \"Hello\"\nMapper sends: [\"Hello\", \"\u03a7\u03b1\u03af\u03c1\u03b5\", \"Hej\", \"\u0928\u092e\u0938\u094d\u0924\u0947\"]\nProgram picks based on: \n- Who you're talking to\n- Recent conversation language\n- Channel/contact settings\n```\n\n### The Universal Vim User\nNever lose your muscle memory again:\n```\nEvery program wrapped with vim mapper:\n- Outlook: Full vim navigation in emails\n- Excel: hjkl cell movement, dd deletes rows\n- Notepad: Finally has text objects\n- Discord: Navigate messages with j/k\n\nOne muscle memory, everywhere.\n```\n\n### The Symbolic Language Pioneer\nCreating a domain-specific language:\n```\nLegal Professional:\n- Chord \"CTR\" \u2192 \u27e8entire copyright clause\u27e9\n- Foot pattern \u2192 \u27e8standard indemnification\u27e9\n- Rhythm \u2192 \u27e8force majeure paragraph\u27e9\n\nChemist:\n- Device combo \u2192 \u27e8benzene ring structure\u27e9\n- Temporal pattern \u2192 \u27e8reaction arrow types\u27e9\n- Multi-device \u2192 \u27e8complex molecules\u27e9\n```\n\n### The Snippet Master\nUniversal code completion without IDE dependency:\n```\nIn any text field, anywhere:\n- \"forr\" \u2192 contextual for loop\n- \"err\" \u2192 language-specific error handling\n- \"test\" \u2192 test suite skeleton\n- \"lic\" \u2192 project license header\n\nYour snippets follow you to email, docs, chat, terminals.\n```\n\n### The Temporal Command Composer\nBuilding complex commands through time:\n```\n\\\\forr \u2192 [wait] \u2192 simple for loop\n\\\\forr\\\\if \u2192 nested for-if structure\n\\\\forr10\\\\brek5 \u2192 for loop to 10, break at 5\n\\\\class\\\\init\\\\prop3 \u2192 class with constructor and 3 properties\n\nTime becomes syntax.\n```\n\n### The Community Computer Lab\nOne PC serving an entire classroom or internet caf\u00e9:\n```\nTraditional: 10 workstations = $10,000\nOur approach: 1 powerful PC + 10 keyboard/mouse/monitor sets = $3,500\n\nEach student/user has:\n- Dedicated monitor with mouse confinement\n- Personal keyboard for their session\n- Full software access (not thin clients)\n- Ability to collaborate by routing to shared spaces\n\nTeacher can:\n- Override routing to demonstrate on any screen\n- Lock students to specific applications\n- Enable pair programming with input merging\n```\n\n### The Family Computer Revolution\n```\nMorning: \n- Parent 1: Monitor 1-2 for work (confined mouse)\n- Kids: Monitor 3 for school (isolated inputs)\n\nEvening:\n- Parent 2: Monitor 1 for emails\n- Parent 1: Monitor 2 for browsing\n- Kid 1: Monitor 3 for homework\n- Kid 2: Monitor 4 for games\n\nOne PC, four simultaneous users, zero conflicts.\nSwitch from isolation to collaboration with a foot pedal.\n```\n\n---\n\n## Implementation Roadmap\n\n### Phase 1: Core Infrastructure\n1. **Input Router MVP**\n   - Basic device identification\n   - Simple exclusive routing\n   - Raw event pass-through\n\n2. **Basic Window Manager**\n   - i3-like tiling\n   - Temporal commands\n   - Device-aware focus\n\n### Phase 2: Intelligence Layer\n1. **Mapper Framework**\n   - Plugin architecture\n   - Rhythm detection\n   - Cross-device patterns\n\n2. **Font Layer Hooks**\n   - DirectWrite interception\n   - Universal vim motions\n   - Spatial navigation map\n\n### Phase 3: Visual Systems\n1. **Priority Graph**\n   - Basic visualization\n   - Drag interaction\n   - Physics simulation\n\n2. **Configuration UI**\n   - Visual router rules\n   - Mapper selection\n   - Device management\n\n### Phase 4: Polish and Integration\n1. **Performance Optimization**\n   - Zero-latency path\n   - GPU acceleration for graph\n   - Efficient pattern matching\n\n2. **Ecosystem**\n   - Plugin marketplace\n   - Community mappers\n   - Device profiles\n\n---\n\n## Conclusion: The Future of Human-Computer Interaction\n\nThis isn't just about making Windows better. It's about fundamentally rethinking how humans interact with computers:\n\n- **Input Liberation**: Every device becomes expressive\n- **Visual Control**: See and manipulate system behavior\n- **Multi-User Reality**: One PC, many users, no conflicts\n- **Temporal Interfaces**: Time becomes a dimension of interaction\n- **Universal Consistency**: Same muscle memory everywhere\n\nWe're not building tools. We're building a new grammar for human-computer interaction.\n\nThe keyboard and mouse were invented decades ago. The WIMP (Windows, Icons, Menus, Pointer) interface is from 1973. Modifier keys are a limitation, not a feature.\n\nIt's time to evolve.\n\n---\n\n## Technical Appendix\n\n### Router Command Protocol\n```\nroute device:<id> to program:<name> [exclusive|shared]\nadd-listener device:<id> to program:<name>\nremove-listener device:<id> from program:<name>\nset-mapper device:<id> program:<name> mapper:<type>\n```\n\n### Mapper Types\n- `raw`: No interpretation, pure hardware events\n- `vim`: Vim-like navigation and commands\n- `media`: Targeted media player control with temporal routing\n- `gaming`: Low-latency, focus-independent, direct-to-game routing\n- `rhythm`: Pattern detection with timing\n- `language:<locale>`: Automatic keyboard layout (e.g., `language:el_GR`, `language:sa_IN`)\n- `multi-language`: Sends multiple interpretations for program-side selection\n- `snippet`: Context-aware text expansion\n- `symbolic`: Custom symbol generation from patterns\n- `temporal`: Time-based command composition\n- `custom:<plugin>`: User-defined mappers\n\n### Mapper Wrapper Architecture\n```\nTraditional:\nDevice \u2192 OS \u2192 Program (limited to OS-provided input)\n\nWith Wrapper:\nDevice \u2192 Router \u2192 Mapper Wrapper \u2192 Program\n                        \u2193\n                 Transforms input\n                 Adds capabilities\n                 Provides consistency\n```\n\n**Example Wrapper Configurations:**\n```json\n{\n  \"wrapper_id\": \"vim_everywhere\",\n  \"type\": \"vim\",\n  \"programs\": [\"notepad.exe\", \"outlook.exe\", \"discord.exe\"],\n  \"config\": {\n    \"leader_key\": \"\\\\\",\n    \"timeout_ms\": 100,\n    \"visual_block\": true\n  }\n}\n\n{\n  \"wrapper_id\": \"polyglot_mode\", \n  \"type\": \"multi-language\",\n  \"programs\": [\"*\"],  // all programs\n  \"config\": {\n    \"languages\": [\"en_US\", \"el_GR\", \"da_DK\", \"sa_IN\"],\n    \"detection\": \"automatic\",\n    \"fallback\": \"en_US\"\n  }\n}\n\n{\n  \"wrapper_id\": \"gaming_performance\",\n  \"type\": \"gaming\",\n  \"programs\": [\"game.exe\"],\n  \"config\": {\n    \"exclusive_device_access\": true,\n    \"bypass_window_manager\": true,\n    \"focus_independent\": true,\n    \"polling_rate_hz\": 1000\n  }\n}\n```\n\n### Context Discovery API\nPrograms can provide hints to mappers:\n```json\n{\n  \"program\": \"vscode\",\n  \"context\": {\n    \"filename\": \"main.py\",\n    \"language\": \"python\",\n    \"project\": \"web_scraper\",\n    \"cursor\": { \"line\": 42, \"column\": 15 },\n    \"selection\": null\n  }\n}\n```\n\nMappers can also discover context via:\n- Font rendering interception\n- Window title analysis\n- Process memory inspection (with permission)\n- Historical usage patterns\n\n### Physics Parameters\n```json\n{\n  \"model\": \"spring|gravity|quantum\",\n  \"mass\": 1.0-10000.0,\n  \"gravity_constant\": 0.1-100.0,\n  \"damping\": 0.0-1.0,\n  \"quantum_tunnel_probability\": 0.0-0.1\n}\n```\n\n### Device Capabilities Discovery\n```json\n{\n  \"device_id\": \"0x1234\",\n  \"type\": \"keyboard|mouse|pedal|custom\",\n  \"capabilities\": {\n    \"keys\": 104,\n    \"has_pressure\": false,\n    \"has_hold_release\": true,\n    \"max_chord_size\": 6\n  }\n}\n```\n\n---\n\n*\"The best interface is no interface. The best computer is the one that disappears. But until we reach that future, let's at least make our interfaces as fluid, expressive, and humane as possible.\"*\n\n## Philosophical Implications: Accidental Revolutions\n\nThis system accidentally enables capabilities we never intended:\n\n### Post-Keyboard Communication\nWhen you free input from physical keyboard constraints, you enable:\n- Million-symbol languages using chords/rhythms/devices\n- Professional domains creating their own symbolic systems\n- Temporal patterns as linguistic elements\n- Cross-device \"sentences\" that span multiple inputs\n\n### Universal Consistency\nThe wrapper architecture means:\n- Learn vim once, use it literally everywhere\n- Your snippets work in every program\n- Your workflows become portable across machines\n- Muscle memory becomes universal, not application-specific\n\n### Democratized Multi-User Computing\nOne powerful PC serves many users because:\n- Input routing makes device ownership meaningful\n- Each person's peripherals become their \"terminal\"\n- No virtualization overhead or remote desktop lag\n- Families/teams share hardware without sharing sessions\n\n**It's a software solution that makes hardware work as independent computers simultaneously.** The window manager can segment monitors, confine mouse movement, and maintain separate focus for each user - effectively creating multiple workstations from one PC.\n\nWant to collaborate? Route input to a shared program instead of the window manager. Want isolation? Each user's devices only affect their assigned monitors. It's dynamically configurable based on need.\n\n### True Parallel Control\nTraditional computing forces sequential focus - one program at a time receives input. Our system enables genuine simultaneous control:\n- Game with left hand while typing docs with right hand\n- Control multiple programs without switching focus\n- Eye tracking for instant context switching while hands keep working\n- Every device can have independent, persistent targets\n\nThis isn't multitasking. It's multi-DOING.\n\n### Time as Interface\nTemporal patterns make time a design element:\n- Rhythm becomes syntax\n- Pauses carry meaning\n- Speed indicates intent\n- Music theory applies to computing\n\nWe didn't set out to revolutionize human-computer interaction. We just wanted better window management and input routing. But by questioning fundamental assumptions\u2014Why only 4 modifier keys? Why one user per PC? Why can't every program have vim?\u2014we accidentally created a foundation for entirely new ways of computing.\n\nThe concept of \"window focus\" becomes obsolete when every device can independently target any program. A computer becomes not a single-task machine that switches contexts, but a true parallel processing environment for human input.\n\n## The Economic Game-Changer\n\nThis isn't just about power users - it's about democratizing computing:\n\n**For Families**: Instead of buying 4 mediocre computers, buy 1 good computer and 4 sets of peripherals. Better performance for everyone at 1/3 the cost.\n\n**For Schools**: Computer labs need fewer PCs but more monitors. Students get better hardware, schools save money, maintenance is simplified.\n\n**For Developing Nations**: Communities can provide computing access to many more people with the same hardware budget. One gaming PC can serve an entire internet caf\u00e9.\n\n**For Offices**: Hot-desking becomes real - workers bring their keyboard/mouse, plug into any monitor, and have their personal computing environment.\n\nThe future isn't just better tools. It's better grammars for the conversation between human and machine. And it's computing access for everyone, not just those who can afford multiple computers.",
      "created_at": "2025-07-17T17:13:05.455625+00:00"
    },
    {
      "uuid": "fd6e6a98-c0d5-47b0-bee5-c86c4d0c5ae8",
      "filename": "explorer2-shell-implementation.md",
      "content": "# Explorer2: Building a Windows Shell Replacement with Raw Input Capture\n\n## Overview\n\nThis guide details how to build Explorer2.exe, a complete Windows shell replacement that captures all system input at the raw level, enabling revolutionary input transformation while maintaining full Windows compatibility.\n\n## Architecture\n\n### Core Components\n\n```\nExplorer2.exe (Shell)\n\u251c\u2500\u2500 Shell Services\n\u2502   \u251c\u2500\u2500 Taskbar Manager\n\u2502   \u251c\u2500\u2500 Desktop Window Manager\n\u2502   \u251c\u2500\u2500 System Tray Handler\n\u2502   \u2514\u2500\u2500 Start Menu Provider\n\u251c\u2500\u2500 Raw Input System\n\u2502   \u251c\u2500\u2500 Device Enumerator\n\u2502   \u251c\u2500\u2500 Input Capture Engine\n\u2502   \u251c\u2500\u2500 Event Dispatcher\n\u2502   \u2514\u2500\u2500 Performance Monitor\n\u251c\u2500\u2500 Mapper Pipeline\n\u2502   \u251c\u2500\u2500 Pipeline Manager\n\u2502   \u251c\u2500\u2500 Mapper Registry\n\u2502   \u251c\u2500\u2500 Context Engine\n\u2502   \u2514\u2500\u2500 Output Router\n\u2514\u2500\u2500 Legacy Compatibility\n    \u251c\u2500\u2500 SendInput Bridge\n    \u251c\u2500\u2500 Hook Manager\n    \u251c\u2500\u2500 Focus Tracker\n    \u2514\u2500\u2500 Window Manager\n```\n\n## Implementation\n\n### 1. Shell Registration and Startup\n\n```csharp\n// Program.cs - Entry point\nusing System;\nusing System.Diagnostics;\nusing Microsoft.Win32;\n\nnamespace Explorer2\n{\n    class Program\n    {\n        [STAThread]\n        static void Main(string[] args)\n        {\n            // Check if we're being launched as shell\n            if (args.Length > 0 && args[0] == \"/shell\")\n            {\n                RunAsShell();\n            }\n            else\n            {\n                // Interactive setup mode\n                ShellInstaller.Run();\n            }\n        }\n        \n        static void RunAsShell()\n        {\n            try\n            {\n                // Prevent multiple instances\n                using var mutex = new Mutex(true, \"Explorer2_Shell_Mutex\", out bool createdNew);\n                if (!createdNew)\n                {\n                    Environment.Exit(1);\n                }\n                \n                // Initialize core systems\n                var shell = new Explorer2Shell();\n                shell.Initialize();\n                shell.Run();\n            }\n            catch (Exception ex)\n            {\n                // Critical failure - log and restart default shell\n                CrashHandler.LogCriticalError(ex);\n                RestoreDefaultShell();\n            }\n        }\n    }\n}\n\n// ShellInstaller.cs - Handles shell replacement\npublic static class ShellInstaller\n{\n    private const string SHELL_KEY = @\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\";\n    \n    public static void Run()\n    {\n        Console.WriteLine(\"Explorer2 Shell Installer\");\n        Console.WriteLine(\"========================\");\n        Console.WriteLine(\"1. Install as default shell\");\n        Console.WriteLine(\"2. Restore Windows Explorer\");\n        Console.WriteLine(\"3. Run once without installing\");\n        \n        switch (Console.ReadKey().KeyChar)\n        {\n            case '1':\n                InstallAsShell();\n                break;\n            case '2':\n                RestoreExplorer();\n                break;\n            case '3':\n                RunOnce();\n                break;\n        }\n    }\n    \n    private static void InstallAsShell()\n    {\n        try\n        {\n            // Kill existing Explorer\n            foreach (var process in Process.GetProcessesByName(\"explorer\"))\n            {\n                process.Kill();\n                process.WaitForExit();\n            }\n            \n            // Update registry\n            using (var key = Registry.LocalMachine.OpenSubKey(SHELL_KEY, true))\n            {\n                key.SetValue(\"Shell\", $\"\\\"{Application.ExecutablePath}\\\" /shell\");\n            }\n            \n            // Start ourselves as shell\n            Process.Start(Application.ExecutablePath, \"/shell\");\n            \n            Console.WriteLine(\"Explorer2 installed as default shell!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Installation failed: {ex.Message}\");\n            Console.WriteLine(\"Run as Administrator!\");\n        }\n    }\n}\n```\n\n### 2. Core Shell Implementation\n\n```csharp\n// Explorer2Shell.cs - Main shell class\npublic class Explorer2Shell : IDisposable\n{\n    private RawInputManager rawInput;\n    private TaskbarManager taskbar;\n    private DesktopManager desktop;\n    private SystemTrayManager tray;\n    private MapperPipeline pipeline;\n    private bool running = true;\n    \n    public void Initialize()\n    {\n        // Set up process priority for responsiveness\n        Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;\n        \n        // Initialize subsystems in order\n        InitializeDesktop();\n        InitializeTaskbar();\n        InitializeSystemTray();\n        InitializeRawInput();\n        InitializeMapperPipeline();\n        \n        // Register for system events\n        SystemEvents.SessionEnding += OnSessionEnding;\n        SystemEvents.DisplaySettingsChanged += OnDisplaySettingsChanged;\n    }\n    \n    private void InitializeDesktop()\n    {\n        desktop = new DesktopManager();\n        \n        // Create the desktop window\n        var desktopWindow = new DesktopWindow();\n        desktopWindow.CreateHandle();\n        \n        // Set as shell window\n        User32.SetShellWindow(desktopWindow.Handle);\n        \n        // Enable desktop icons, wallpaper, etc.\n        desktop.EnableDesktopIcons();\n        desktop.RestoreWallpaper();\n    }\n    \n    private void InitializeTaskbar()\n    {\n        taskbar = new TaskbarManager();\n        \n        // Create taskbar window\n        var taskbarWindow = new TaskbarWindow();\n        taskbarWindow.Show();\n        \n        // Register app bar\n        var appBarData = new APPBARDATA\n        {\n            cbSize = Marshal.SizeOf<APPBARDATA>(),\n            hWnd = taskbarWindow.Handle,\n            uEdge = ABE_BOTTOM\n        };\n        Shell32.SHAppBarMessage(ABM_NEW, ref appBarData);\n        \n        // Set position\n        taskbar.UpdatePosition();\n        \n        // Start monitoring running applications\n        taskbar.StartApplicationMonitoring();\n    }\n    \n    private void InitializeRawInput()\n    {\n        rawInput = new RawInputManager();\n        \n        // Register for all input devices\n        var devices = new[]\n        {\n            new RAWINPUTDEVICE\n            {\n                usUsagePage = HID_USAGE_PAGE_GENERIC,\n                usUsage = HID_USAGE_GENERIC_KEYBOARD,\n                dwFlags = RIDEV_INPUTSINK | RIDEV_DEVNOTIFY,\n                hwndTarget = desktop.Handle\n            },\n            new RAWINPUTDEVICE\n            {\n                usUsagePage = HID_USAGE_PAGE_GENERIC,\n                usUsage = HID_USAGE_GENERIC_MOUSE,\n                dwFlags = RIDEV_INPUTSINK | RIDEV_DEVNOTIFY,\n                hwndTarget = desktop.Handle\n            }\n        };\n        \n        if (!RegisterRawInputDevices(devices, devices.Length, Marshal.SizeOf<RAWINPUTDEVICE>()))\n        {\n            throw new Win32Exception(Marshal.GetLastWin32Error());\n        }\n        \n        // Start device enumeration\n        rawInput.EnumerateDevices();\n    }\n    \n    public void Run()\n    {\n        // Main message loop\n        var msg = new MSG();\n        while (running)\n        {\n            if (PeekMessage(out msg, IntPtr.Zero, 0, 0, PM_REMOVE))\n            {\n                if (msg.message == WM_QUIT)\n                {\n                    running = false;\n                    break;\n                }\n                \n                // Handle raw input specially\n                if (msg.message == WM_INPUT)\n                {\n                    ProcessRawInput(msg.lParam);\n                }\n                else\n                {\n                    TranslateMessage(ref msg);\n                    DispatchMessage(ref msg);\n                }\n            }\n            else\n            {\n                // No messages - do background work\n                Thread.Sleep(1);\n                pipeline.ProcessBufferedEvents();\n            }\n        }\n    }\n}\n```\n\n### 3. Raw Input Capture System\n\n```csharp\n// RawInputManager.cs - Core input capture\npublic class RawInputManager\n{\n    private readonly Dictionary<IntPtr, InputDevice> devices = new();\n    private readonly Subject<RawInputEvent> inputStream = new();\n    private readonly PerformanceCounter perfCounter = new();\n    \n    public IObservable<RawInputEvent> InputStream => inputStream.AsObservable();\n    \n    public void ProcessRawInput(IntPtr lParam)\n    {\n        uint dwSize = 0;\n        \n        // Get size of input data\n        GetRawInputData(lParam, RID_INPUT, IntPtr.Zero, ref dwSize, Marshal.SizeOf<RAWINPUTHEADER>());\n        \n        if (dwSize == 0) return;\n        \n        // Allocate buffer\n        var buffer = Marshal.AllocHGlobal((int)dwSize);\n        try\n        {\n            // Get the actual data\n            if (GetRawInputData(lParam, RID_INPUT, buffer, ref dwSize, Marshal.SizeOf<RAWINPUTHEADER>()) == dwSize)\n            {\n                // Parse the input\n                var raw = Marshal.PtrToStructure<RAWINPUT>(buffer);\n                \n                // Track performance\n                perfCounter.InputReceived();\n                \n                // Convert to our event format\n                var inputEvent = ConvertRawInput(raw);\n                if (inputEvent != null)\n                {\n                    // Send through pipeline\n                    inputStream.OnNext(inputEvent);\n                }\n            }\n        }\n        finally\n        {\n            Marshal.FreeHGlobal(buffer);\n        }\n    }\n    \n    private RawInputEvent ConvertRawInput(RAWINPUT raw)\n    {\n        // Get device info\n        if (!devices.TryGetValue(raw.header.hDevice, out var device))\n        {\n            device = EnumerateDevice(raw.header.hDevice);\n            devices[raw.header.hDevice] = device;\n        }\n        \n        switch (raw.header.dwType)\n        {\n            case RIM_TYPEKEYBOARD:\n                return ConvertKeyboardInput(raw.keyboard, device);\n                \n            case RIM_TYPEMOUSE:\n                return ConvertMouseInput(raw.mouse, device);\n                \n            case RIM_TYPEHID:\n                return ConvertHIDInput(raw.hid, device);\n                \n            default:\n                return null;\n        }\n    }\n    \n    private RawInputEvent ConvertKeyboardInput(RAWKEYBOARD keyboard, InputDevice device)\n    {\n        return new RawInputEvent\n        {\n            Device = device,\n            Type = InputType.Keyboard,\n            Timestamp = GetHighResolutionTimestamp(),\n            Keyboard = new KeyboardData\n            {\n                ScanCode = keyboard.MakeCode,\n                VirtualKey = keyboard.VKey,\n                Flags = (KeyboardFlags)keyboard.Flags,\n                IsDown = (keyboard.Flags & RI_KEY_BREAK) == 0,\n                IsExtended = (keyboard.Flags & RI_KEY_E0) != 0\n            }\n        };\n    }\n    \n    public void EnumerateDevices()\n    {\n        uint deviceCount = 0;\n        uint deviceSize = (uint)Marshal.SizeOf<RAWINPUTDEVICELIST>();\n        \n        // Get device count\n        GetRawInputDeviceList(IntPtr.Zero, ref deviceCount, deviceSize);\n        \n        if (deviceCount == 0) return;\n        \n        // Allocate buffer for device list\n        var deviceList = new RAWINPUTDEVICELIST[deviceCount];\n        var gcHandle = GCHandle.Alloc(deviceList, GCHandleType.Pinned);\n        \n        try\n        {\n            // Get device list\n            GetRawInputDeviceList(gcHandle.AddrOfPinnedObject(), ref deviceCount, deviceSize);\n            \n            // Process each device\n            foreach (var device in deviceList)\n            {\n                var info = GetDeviceInfo(device.hDevice);\n                devices[device.hDevice] = info;\n                \n                // Notify device connected\n                OnDeviceConnected(info);\n            }\n        }\n        finally\n        {\n            gcHandle.Free();\n        }\n    }\n    \n    private InputDevice GetDeviceInfo(IntPtr hDevice)\n    {\n        uint size = 0;\n        GetRawInputDeviceInfo(hDevice, RIDI_DEVICEINFO, IntPtr.Zero, ref size);\n        \n        var buffer = Marshal.AllocHGlobal((int)size);\n        try\n        {\n            GetRawInputDeviceInfo(hDevice, RIDI_DEVICEINFO, buffer, ref size);\n            var info = Marshal.PtrToStructure<RID_DEVICE_INFO>(buffer);\n            \n            // Get device name\n            GetRawInputDeviceInfo(hDevice, RIDI_DEVICENAME, IntPtr.Zero, ref size);\n            var nameBuffer = Marshal.AllocHGlobal((int)size * 2); // Unicode\n            string deviceName = \"\";\n            \n            try\n            {\n                GetRawInputDeviceInfo(hDevice, RIDI_DEVICENAME, nameBuffer, ref size);\n                deviceName = Marshal.PtrToStringUni(nameBuffer);\n            }\n            finally\n            {\n                Marshal.FreeHGlobal(nameBuffer);\n            }\n            \n            return new InputDevice\n            {\n                Handle = hDevice,\n                Name = deviceName,\n                Type = GetDeviceType(info),\n                VendorId = info.hid.dwVendorId,\n                ProductId = info.hid.dwProductId,\n                VersionNumber = info.hid.dwVersionNumber\n            };\n        }\n        finally\n        {\n            Marshal.FreeHGlobal(buffer);\n        }\n    }\n}\n\n// PerformanceMonitor.cs - Track input performance\npublic class InputPerformanceMonitor\n{\n    private readonly CircularBuffer<long> latencies = new(1000);\n    private readonly Stopwatch stopwatch = Stopwatch.StartNew();\n    private long lastInputTime;\n    \n    public void InputReceived()\n    {\n        var now = stopwatch.ElapsedTicks;\n        if (lastInputTime != 0)\n        {\n            var latency = now - lastInputTime;\n            latencies.Add(latency);\n        }\n        lastInputTime = now;\n    }\n    \n    public InputPerformanceStats GetStats()\n    {\n        var latencyArray = latencies.ToArray();\n        if (latencyArray.Length == 0)\n        {\n            return new InputPerformanceStats();\n        }\n        \n        Array.Sort(latencyArray);\n        \n        return new InputPerformanceStats\n        {\n            AverageLatencyMs = TicksToMs(latencyArray.Average()),\n            P99LatencyMs = TicksToMs(latencyArray[(int)(latencyArray.Length * 0.99)]),\n            P95LatencyMs = TicksToMs(latencyArray[(int)(latencyArray.Length * 0.95)]),\n            MedianLatencyMs = TicksToMs(latencyArray[latencyArray.Length / 2]),\n            InputsPerSecond = latencyArray.Length > 1 ? \n                1000.0 / TicksToMs(latencyArray.Average()) : 0\n        };\n    }\n    \n    private double TicksToMs(double ticks)\n    {\n        return (ticks / Stopwatch.Frequency) * 1000.0;\n    }\n}\n```\n\n### 4. Desktop Window Implementation\n\n```csharp\n// DesktopWindow.cs - The root window that receives input\npublic class DesktopWindow : NativeWindow\n{\n    private const string DESKTOP_CLASS = \"Explorer2Desktop\";\n    private readonly MapperPipeline pipeline;\n    \n    public DesktopWindow(MapperPipeline pipeline)\n    {\n        this.pipeline = pipeline;\n        CreateDesktopWindow();\n    }\n    \n    private void CreateDesktopWindow()\n    {\n        // Register window class\n        var wndClass = new WNDCLASSEX\n        {\n            cbSize = Marshal.SizeOf<WNDCLASSEX>(),\n            style = CS_DBLCLKS,\n            lpfnWndProc = WndProc,\n            hInstance = GetModuleHandle(null),\n            hCursor = LoadCursor(IntPtr.Zero, IDC_ARROW),\n            hbrBackground = (IntPtr)(COLOR_DESKTOP + 1),\n            lpszClassName = DESKTOP_CLASS\n        };\n        \n        RegisterClassEx(ref wndClass);\n        \n        // Create window covering entire screen\n        var screenWidth = GetSystemMetrics(SM_CXSCREEN);\n        var screenHeight = GetSystemMetrics(SM_CYSCREEN);\n        \n        var hwnd = CreateWindowEx(\n            0,\n            DESKTOP_CLASS,\n            \"Explorer2 Desktop\",\n            WS_POPUP | WS_VISIBLE | WS_CLIPSIBLINGS,\n            0, 0, screenWidth, screenHeight,\n            IntPtr.Zero,\n            IntPtr.Zero,\n            GetModuleHandle(null),\n            IntPtr.Zero\n        );\n        \n        AssignHandle(hwnd);\n        \n        // Set as desktop window\n        SetShellWindow(hwnd);\n        \n        // Enable drag-drop\n        DragAcceptFiles(hwnd, true);\n    }\n    \n    protected override void WndProc(ref Message m)\n    {\n        switch (m.Msg)\n        {\n            case WM_INPUT:\n                HandleRawInput(m.LParam);\n                break;\n                \n            case WM_INPUT_DEVICE_CHANGE:\n                HandleDeviceChange(m.WParam, m.LParam);\n                break;\n                \n            case WM_CONTEXTMENU:\n                ShowDesktopContextMenu(m.LParam);\n                break;\n                \n            case WM_DROPFILES:\n                HandleFileDrop(m.WParam);\n                break;\n                \n            default:\n                base.WndProc(ref m);\n                break;\n        }\n    }\n    \n    private void HandleRawInput(IntPtr lParam)\n    {\n        try\n        {\n            // Get input data size\n            uint size = 0;\n            GetRawInputData(lParam, RID_INPUT, IntPtr.Zero, ref size, Marshal.SizeOf<RAWINPUTHEADER>());\n            \n            if (size == 0) return;\n            \n            // Process through high-performance path\n            using (var buffer = new UnmanagedBuffer((int)size))\n            {\n                if (GetRawInputData(lParam, RID_INPUT, buffer.Pointer, ref size, Marshal.SizeOf<RAWINPUTHEADER>()) == size)\n                {\n                    // Direct memory access for performance\n                    unsafe\n                    {\n                        var raw = (RAWINPUT*)buffer.Pointer;\n                        ProcessRawInputDirect(raw);\n                    }\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Logger.LogError(\"Raw input processing error\", ex);\n        }\n    }\n    \n    private unsafe void ProcessRawInputDirect(RAWINPUT* raw)\n    {\n        // Ultra-fast processing path\n        var timestamp = QueryPerformanceCounter();\n        \n        switch (raw->header.dwType)\n        {\n            case RIM_TYPEKEYBOARD:\n                var keyEvent = new InputEvent\n                {\n                    Type = InputType.Key,\n                    Device = GetOrCreateDevice(raw->header.hDevice),\n                    RawCode = raw->keyboard.MakeCode,\n                    State = (raw->keyboard.Flags & RI_KEY_BREAK) == 0 ? \n                        InputState.Down : InputState.Up,\n                    Timestamp = timestamp\n                };\n                \n                pipeline.ProcessInputAsync(keyEvent);\n                break;\n                \n            case RIM_TYPEMOUSE:\n                // Process mouse with minimal allocation\n                ProcessMouseDirect(&raw->mouse, raw->header.hDevice, timestamp);\n                break;\n        }\n    }\n}\n```\n\n### 5. Taskbar Implementation\n\n```csharp\n// TaskbarWindow.cs - Modern taskbar with domain support\npublic class TaskbarWindow : Form\n{\n    private readonly FlowLayoutPanel taskButtons;\n    private readonly SystemTray systemTray;\n    private readonly DomainIndicator domainIndicator;\n    private readonly NotificationArea notifications;\n    \n    public TaskbarWindow()\n    {\n        InitializeTaskbar();\n        SetupAppBar();\n    }\n    \n    private void InitializeTaskbar()\n    {\n        // Configure window\n        FormBorderStyle = FormBorderStyle.None;\n        ShowInTaskbar = false;\n        TopMost = true;\n        Height = 40;\n        BackColor = Color.FromArgb(32, 32, 32);\n        \n        // Create layout\n        var layout = new TableLayoutPanel\n        {\n            Dock = DockStyle.Fill,\n            ColumnCount = 4,\n            RowCount = 1\n        };\n        \n        // Start button\n        var startButton = new StartButton();\n        startButton.Click += OnStartClick;\n        layout.Controls.Add(startButton, 0, 0);\n        \n        // Task buttons\n        taskButtons = new FlowLayoutPanel\n        {\n            Dock = DockStyle.Fill,\n            FlowDirection = FlowDirection.LeftToRight,\n            WrapContents = false\n        };\n        layout.Controls.Add(taskButtons, 1, 0);\n        \n        // Domain indicator\n        domainIndicator = new DomainIndicator();\n        layout.Controls.Add(domainIndicator, 2, 0);\n        \n        // System tray\n        systemTray = new SystemTray();\n        layout.Controls.Add(systemTray, 3, 0);\n        \n        Controls.Add(layout);\n    }\n    \n    private void SetupAppBar()\n    {\n        var abd = new APPBARDATA\n        {\n            cbSize = Marshal.SizeOf<APPBARDATA>(),\n            hWnd = Handle,\n            uCallbackMessage = WM_APPBAR_CALLBACK\n        };\n        \n        // Register as app bar\n        SHAppBarMessage(ABM_NEW, ref abd);\n        \n        // Set position\n        abd.uEdge = ABE_BOTTOM;\n        abd.rc = new RECT\n        {\n            left = 0,\n            top = Screen.PrimaryScreen.Bounds.Height - Height,\n            right = Screen.PrimaryScreen.Bounds.Width,\n            bottom = Screen.PrimaryScreen.Bounds.Height\n        };\n        \n        SHAppBarMessage(ABM_SETPOS, ref abd);\n    }\n    \n    public void AddTaskButton(IntPtr hwnd, string title, Icon icon)\n    {\n        var button = new TaskButton\n        {\n            WindowHandle = hwnd,\n            Text = title,\n            Image = icon?.ToBitmap(),\n            Width = 200,\n            Height = 36\n        };\n        \n        button.Click += (s, e) => ActivateWindow(hwnd);\n        button.ContextMenuStrip = CreateTaskContextMenu(hwnd);\n        \n        taskButtons.Controls.Add(button);\n    }\n    \n    private void ActivateWindow(IntPtr hwnd)\n    {\n        // Check if window belongs to current domain\n        var domain = DomainManager.GetWindowDomain(hwnd);\n        if (domain != DomainManager.CurrentDomain)\n        {\n            // Show domain switch prompt\n            if (MessageBox.Show(\n                $\"This window belongs to {domain.Name}. Switch domain?\",\n                \"Domain Switch\",\n                MessageBoxButtons.YesNo) == DialogResult.Yes)\n            {\n                DomainManager.SwitchToDomain(domain);\n            }\n            else\n            {\n                return;\n            }\n        }\n        \n        // Activate the window\n        SetForegroundWindow(hwnd);\n        \n        // Restore if minimized\n        if (IsIconic(hwnd))\n        {\n            ShowWindow(hwnd, SW_RESTORE);\n        }\n    }\n}\n\n// DomainIndicator.cs - Shows current input domain\npublic class DomainIndicator : UserControl\n{\n    private Label domainLabel;\n    private PictureBox userIcon;\n    \n    public DomainIndicator()\n    {\n        Width = 150;\n        \n        userIcon = new PictureBox\n        {\n            Size = new Size(32, 32),\n            Location = new Point(4, 4),\n            SizeMode = PictureBoxSizeMode.Zoom\n        };\n        \n        domainLabel = new Label\n        {\n            Location = new Point(40, 8),\n            Size = new Size(106, 24),\n            TextAlign = ContentAlignment.MiddleLeft,\n            ForeColor = Color.White\n        };\n        \n        Controls.AddRange(new Control[] { userIcon, domainLabel });\n        \n        // Subscribe to domain changes\n        DomainManager.DomainChanged += OnDomainChanged;\n        UpdateDisplay();\n    }\n    \n    private void OnDomainChanged(object sender, DomainChangedEventArgs e)\n    {\n        UpdateDisplay();\n    }\n    \n    private void UpdateDisplay()\n    {\n        var domain = DomainManager.CurrentDomain;\n        domainLabel.Text = domain.Name;\n        userIcon.Image = domain.UserIcon;\n        BackColor = domain.ThemeColor;\n    }\n    \n    protected override void OnClick(EventArgs e)\n    {\n        // Show domain switcher\n        var switcher = new DomainSwitcher();\n        switcher.Show(this, new Point(0, -switcher.Height));\n    }\n}\n```\n\n### 6. Critical System Integration\n\n```csharp\n// SystemIntegration.cs - Ensures Windows continues to work\npublic static class SystemIntegration\n{\n    public static void EnsureCriticalServices()\n    {\n        // Start critical Windows services our shell needs\n        EnsureService(\"Themes\");      // Visual styles\n        EnsureService(\"AudioSrv\");    // Sound\n        EnsureService(\"Spooler\");     // Printing\n        EnsureService(\"ShellHWDetection\"); // Hardware\n        \n        // Initialize COM\n        CoInitializeEx(IntPtr.Zero, COINIT_APARTMENTTHREADED);\n        \n        // Register for power notifications\n        RegisterPowerSettingNotification(\n            Process.GetCurrentProcess().Handle,\n            ref GUID_CONSOLE_DISPLAY_STATE,\n            DEVICE_NOTIFY_CALLBACK);\n        \n        // Set up file associations\n        RestoreFileAssociations();\n        \n        // Initialize notification system\n        InitializeNotificationPlatform();\n    }\n    \n    private static void RestoreFileAssociations()\n    {\n        // Ensure file types open correctly\n        var assocKey = Registry.CurrentUser.OpenSubKey(\n            @\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\",\n            true);\n        \n        // Re-register common types\n        RegisterFileType(\".exe\", \"exefile\", \"Application\");\n        RegisterFileType(\".txt\", \"txtfile\", \"Text Document\");\n        RegisterFileType(\".jpg\", \"jpegfile\", \"JPEG Image\");\n        // ... etc\n    }\n    \n    public static void HandleCriticalError(Exception ex)\n    {\n        // Log error\n        EventLog.WriteEntry(\"Explorer2\", \n            $\"Critical error: {ex.Message}\\n{ex.StackTrace}\", \n            EventLogEntryType.Error);\n        \n        // Show user-friendly error\n        MessageBox.Show(\n            \"Explorer2 encountered an error and needs to restart.\\n\\n\" +\n            \"Your work has been saved.\",\n            \"Explorer2\",\n            MessageBoxButtons.OK,\n            MessageBoxIcon.Error);\n        \n        // Restart shell\n        RestartShell();\n    }\n    \n    private static void RestartShell()\n    {\n        // Save state\n        SaveShellState();\n        \n        // Start new instance\n        Process.Start(Application.ExecutablePath, \"/shell\");\n        \n        // Exit this instance\n        Environment.Exit(1);\n    }\n}\n\n// CrashHandler.cs - Graceful failure handling\npublic static class CrashHandler\n{\n    public static void Install()\n    {\n        AppDomain.CurrentDomain.UnhandledException += OnUnhandledException;\n        Application.ThreadException += OnThreadException;\n        Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);\n    }\n    \n    private static void OnUnhandledException(object sender, UnhandledExceptionEventArgs e)\n    {\n        var ex = e.ExceptionObject as Exception;\n        LogCriticalError(ex);\n        \n        if (e.IsTerminating)\n        {\n            // We're going down - ensure Windows has a shell\n            EnsureShellContinuity();\n        }\n    }\n    \n    private static void EnsureShellContinuity()\n    {\n        try\n        {\n            // Try to restart ourselves\n            Process.Start(Application.ExecutablePath, \"/shell /recovery\");\n        }\n        catch\n        {\n            // Failed - restore Windows Explorer\n            try\n            {\n                Process.Start(\"explorer.exe\");\n            }\n            catch\n            {\n                // System is in bad state - trigger Windows recovery\n                Native.NtRaiseHardError(\n                    0xC0000135, // STATUS_DLL_NOT_FOUND\n                    0, 0, IntPtr.Zero, 0, \n                    out uint response);\n            }\n        }\n    }\n}\n```\n\n### 7. Performance Optimizations\n\n```csharp\n// HighPerformanceInput.cs - Optimized input processing\npublic class HighPerformanceInputProcessor\n{\n    private readonly ThreadLocal<InputBatch> threadLocalBatch;\n    private readonly BlockingCollection<InputBatch> batchQueue;\n    private readonly Thread[] workerThreads;\n    \n    public HighPerformanceInputProcessor(int threadCount = 4)\n    {\n        threadLocalBatch = new ThreadLocal<InputBatch>(() => new InputBatch());\n        batchQueue = new BlockingCollection<InputBatch>();\n        \n        // Start worker threads\n        workerThreads = new Thread[threadCount];\n        for (int i = 0; i < threadCount; i++)\n        {\n            workerThreads[i] = new Thread(ProcessBatches)\n            {\n                Name = $\"InputProcessor{i}\",\n                IsBackground = false,\n                Priority = ThreadPriority.Highest\n            };\n            workerThreads[i].Start();\n        }\n    }\n    \n    public void ProcessInput(RawInputEvent input)\n    {\n        var batch = threadLocalBatch.Value;\n        batch.Add(input);\n        \n        if (batch.Count >= 32 || batch.Age > TimeSpan.FromMilliseconds(1))\n        {\n            batchQueue.Add(batch);\n            threadLocalBatch.Value = new InputBatch();\n        }\n    }\n    \n    private void ProcessBatches()\n    {\n        // Pin thread to CPU core\n        Thread.BeginThreadAffinity();\n        \n        // Reduce GC pressure\n        GC.TryStartNoGCRegion(10 * 1024 * 1024); // 10MB\n        \n        try\n        {\n            foreach (var batch in batchQueue.GetConsumingEnumerable())\n            {\n                ProcessBatchOptimized(batch);\n                batch.Return(); // Object pooling\n            }\n        }\n        finally\n        {\n            GC.EndNoGCRegion();\n            Thread.EndThreadAffinity();\n        }\n    }\n    \n    private unsafe void ProcessBatchOptimized(InputBatch batch)\n    {\n        // Process in tight loop with minimal allocations\n        fixed (InputEvent* events = batch.Events)\n        {\n            for (int i = 0; i < batch.Count; i++)\n            {\n                var evt = events[i];\n                \n                // Fast path for gaming input\n                if (evt.Domain.IsGaming && evt.Device.IsGamingDevice)\n                {\n                    DirectInject(&evt);\n                }\n                else\n                {\n                    // Normal pipeline\n                    pipeline.Process(evt);\n                }\n            }\n        }\n    }\n}\n```\n\n## Installation and Configuration\n\n### Registry Settings\n\n```registry\nWindows Registry Editor Version 5.00\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon]\n\"Shell\"=\"C:\\\\Program Files\\\\Explorer2\\\\Explorer2.exe /shell\"\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Explorer2]\n\"Version\"=\"1.0.0\"\n\"InstallPath\"=\"C:\\\\Program Files\\\\Explorer2\"\n\"ConfigPath\"=\"C:\\\\ProgramData\\\\Explorer2\\\\Config\"\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Explorer2\\Mappers]\n\"Path\"=\"C:\\\\ProgramData\\\\Explorer2\\\\Mappers\"\n\"AutoLoad\"=dword:00000001\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Explorer2\\Performance]\n\"InputThreads\"=dword:00000004\n\"BatchSize\"=dword:00000020\n\"MaxLatencyMs\"=dword:00000001\n```\n\n### Configuration File\n\n```xml\n<!-- Explorer2.config -->\n<configuration>\n  <shell>\n    <taskbar position=\"bottom\" height=\"40\" autohide=\"false\" />\n    <desktop showIcons=\"true\" wallpaper=\"preserve\" />\n    <startMenu style=\"modern\" />\n  </shell>\n  \n  <input>\n    <performance>\n      <threading model=\"dedicated\" count=\"4\" />\n      <batching enabled=\"true\" size=\"32\" />\n      <latency target=\"1ms\" />\n    </performance>\n    \n    <devices>\n      <enumeration interval=\"1000\" />\n      <persistence enabled=\"true\" />\n    </devices>\n  </input>\n  \n  <domains>\n    <isolation level=\"strict\" />\n    <switching animation=\"fade\" duration=\"200\" />\n  </domains>\n  \n  <compatibility>\n    <legacyBridge enabled=\"true\" />\n    <sendInput mode=\"hardware\" />\n    <hooks allowed=\"true\" />\n  </compatibility>\n</configuration>\n```\n\n## Deployment\n\n### MSI Installer Structure\n\n```\nExplorer2.msi\n\u251c\u2500\u2500 Program Files/\n\u2502   \u2514\u2500\u2500 Explorer2/\n\u2502       \u251c\u2500\u2500 Explorer2.exe (signed)\n\u2502       \u251c\u2500\u2500 Explorer2.Core.dll\n\u2502       \u251c\u2500\u2500 Explorer2.Input.dll\n\u2502       \u251c\u2500\u2500 Explorer2.UI.dll\n\u2502       \u2514\u2500\u2500 Mappers/\n\u2502           \u251c\u2500\u2500 Vim.dll\n\u2502           \u251c\u2500\u2500 Gaming.dll\n\u2502           \u2514\u2500\u2500 Temporal.dll\n\u251c\u2500\u2500 ProgramData/\n\u2502   \u2514\u2500\u2500 Explorer2/\n\u2502       \u251c\u2500\u2500 Config/\n\u2502       \u251c\u2500\u2500 Logs/\n\u2502       \u2514\u2500\u2500 Mappers/\n\u2514\u2500\u2500 Registry entries\n```\n\n### Safety Features\n\n1. **Automatic Fallback**: If Explorer2 crashes 3 times in 5 minutes, Windows Explorer is restored\n2. **Safe Mode**: Hold Shift during boot to use Windows Explorer\n3. **Recovery Command**: `explorer2 /restore` reverts to Windows Explorer\n4. **Logging**: Comprehensive logging for debugging\n\n## Conclusion\n\nExplorer2 provides a complete shell replacement that:\n\n1. **Captures all raw input** before any application sees it\n2. **Maintains Windows compatibility** through careful system integration\n3. **Enables revolutionary input routing** through the mapper pipeline\n4. **Performs at native speed** through optimized processing\n5. **Fails gracefully** with automatic recovery\n\nThis foundation enables the complete mapper/router system while keeping Windows stable and responsive. Users get a revolutionary input experience without sacrificing reliability.",
      "created_at": "2025-07-17T17:30:30.731295+00:00"
    },
    {
      "uuid": "e6662e37-bb8f-4a7d-9661-4059d820c336",
      "filename": "windows-input-mapper-human.md",
      "content": "# Windows Input Revolution: A Multi-User System That Actually Makes Sense\n\n## The Big Idea\n\nImagine if your computer actually understood what you wanted to do, not just what keys you pressed. What if Dad's keyboard worked his way, Mom's worked hers, and the kids could game on the same PC\u2014all at the same time? What if every game instantly knew you prefer ESDF instead of WASD, without setting it up each time?\n\nThis document describes a new way of handling input on Windows that makes all of this possible, without the billion-dollar kernel rewrite that Microsoft thought was necessary.\n\n## How It Works: The Clever Hack\n\nInstead of rewriting Windows from scratch, we use a simple trick: we replace the Windows desktop (Explorer.exe) with our own version. When Windows starts, it runs our program instead, and we become the traffic controller for all input devices.\n\nThink of it like replacing your home's circuit breaker panel. We don't rewire the whole house\u2014we just put a smart panel in front that routes electricity (input) exactly where it needs to go.\n\n## The Magic: Separating \"What\" from \"How\"\n\n### The Problem Today\n\nRight now, every program thinks in terms of physical keys:\n- Games say \"Press W to move forward\"  \n- Each game makes you configure controls separately\n- If you prefer different keys, tough luck\u2014set it up again in every program\n- Two people can't use the same computer simultaneously\n\n### Our Solution\n\nPrograms should say what they need, not how to do it:\n- Game says \"I need a way to move forward\"\n- Our system knows YOU prefer E for forward\n- Game gets \"move forward\" command when you press E\n- Your preferences work everywhere automatically\n\n## The Pipeline: How Input Flows\n\nThink of input like water flowing through customizable pipes:\n\n1. **You press a key** \u2192 Raw physical input\n2. **Device Router** \u2192 \"This came from Dad's keyboard\"  \n3. **Mapper Pipeline** \u2192 A series of smart filters that transform input\n4. **Application** \u2192 Gets exactly what it needs\n\n### Types of Mappers (Smart Filters)\n\n**Simple Remapper**\n- \"When I press E, send W to the game\"\n- Like having a permanent translator for your preferred layout\n\n**Temporal Mapper** \n- \"If I quickly press J then K within 50ms, send Escape\"\n- Enables Vim-style commands everywhere\n- \"Type \\\\\\\\ to open command palette\" \n\n**Modal Mapper**\n- Press Q: \"Now I'm in building mode\"\n- Press W: \"Now I'm in combat mode\"  \n- Same keys do completely different things based on mode\n- Like having multiple keyboards in one\n\n**Context Mapper**\n- In a game: E means \"move forward\"\n- In a text editor: E means the letter E\n- Automatically switches based on what program you're using\n\n## Real-World Examples\n\n### Family Computer Scenario\n\n**Morning: Dad's Working**\n- His keyboard and mouse control the main monitor\n- Uses Vim shortcuts in all programs\n- Kids' keyboards/mice are inactive on his screen\n\n**Afternoon: Kids' Homework Time**  \n- Sarah's pink keyboard controls the left monitor\n- Tom's gaming keyboard controls the right monitor\n- Both work independently, can't interfere with each other\n- Dad's work remains secure and untouched\n\n**Evening: Family Game Night**\n- All devices active for party games\n- Or kids play separate games on same PC\n- No fighting over the computer!\n\n### RTS Player's Dream\n\nYou're playing StarCraft. Instead of memorizing 50+ hotkeys:\n\n**Press Q - ECONOMY MODE**\n- A builds workers\n- S builds supply depots  \n- D builds defenses\n- Number keys queue multiple units\n\n**Press W - COMBAT MODE**  \n- A is now attack-move\n- S is now stop\n- D is now defensive stance\n- Same keys, completely different functions!\n\n**Press E - SCOUTING MODE**\n- A/S/D/F become camera positions\n- Easy to monitor the whole map\n- Q cycles through enemy buildings\n\nThe genius: Q/W/E always switch modes, so you only memorize 3 keys instead of 50.\n\n### Universal Vim Mode\n\nLove Vim? Now EVERY program can work like Vim:\n- Press \"jk\" quickly to exit insert mode\n- Use hjkl for navigation in any application\n- Your muscle memory works everywhere\n- Non-Vim users unaffected\u2014it's YOUR preference\n\n## Device Management: Solving the USB Problem\n\n### The Current Mess\n- Plug in a mouse\u2014which user does it belong to?\n- USB devices have terrible identification\n- Same model mice are indistinguishable  \n- Ports change, IDs are meaningless\n\n### Our Solution\n\nWhen you plug in a new device:\n\n1. **Friendly Introduction**\n   - \"New mouse detected! Who uses this?\"\n   - \"What will you use it for? Gaming? Work?\"\n   - Give it a nickname: \"Dad's work mouse\"\n\n2. **Behavioral Fingerprinting**\n   - \"Move the mouse around for 5 seconds\"\n   - We learn your unique usage patterns\n   - Can identify YOUR mouse even if identical models exist\n\n3. **Smart Assignment**\n   - Remembers device preferences\n   - Auto-assigns to your domain when plugged in\n   - Falls back gracefully if unsure\n\n## Making Old Software Work\n\nThe beauty: existing programs don't need to change. When an old game expects WASD but you prefer ESDF, we:\n\n1. Intercept your ESDF presses\n2. Translate to WASD automatically  \n3. Send to the game\n4. Game works perfectly, your way\n\nWe maintain a database of popular software and their expected inputs, so everything \"just works.\"\n\n## Performance: Having Your Cake and Eating It\n\n**Gaming Mouse in FPS?**\n- Direct pass-through, near-zero latency\n- Maybe 100 nanoseconds overhead (imperceptible)\n\n**Typing with Temporal Commands?**  \n- Intentional 50ms delay to detect patterns\n- Still faster than reaching for Escape key\n- Only active where you want it\n\n**The Smart Part:** The system knows when to be fast and when to be smart.\n\n## Security & Privacy\n\nEach domain is isolated:\n- Kids can't keylog Dad's passwords\n- Work domain separate from gaming\n- Clipboard isolation between domains\n- Screen boundaries enforced\n\nLike having separate computers that share hardware.\n\n## Why This Changes Everything\n\n### For Families\n- One good PC instead of four cheap ones\n- Everyone's preferences preserved\n- Natural sharing without conflicts\n- Huge cost savings\n\n### For Power Users  \n- Your input preferences everywhere\n- Modal interfaces like never before\n- Programmable everything\n- Zero learning curve for new software\n\n### For Gamers\n- Controls consistent across all games\n- Advanced macro capabilities\n- Mode-based interfaces for complex games\n- No more config file hunting\n\n### For Accessibility\n- Remap anything for physical needs\n- Works across all software\n- One configuration, works everywhere\n- Voice/alternative input integration\n\n## Implementation: Easier Than You Think\n\n**Week 1:** Basic shell replacement and input capture\n**Week 2-3:** Mapper system and configuration UI  \n**Week 4-5:** Semantic layer and app compatibility\n**Week 6-8:** Polish and advanced features\n\nTotal development time: 2 months\nTotal cost: One developer's time\nMicrosoft's estimate: $3 billion and 5 years\n\n## The Bottom Line\n\nThis isn't a billion-dollar kernel rewrite. It's a clever use of existing Windows features to solve real problems:\n\n- Multiple people using one computer effectively\n- Input preferences that follow you everywhere\n- Modal interfaces that reduce complexity\n- Complete backward compatibility\n\nBy thinking differently about the problem\u2014replacing the shell instead of the kernel\u2014we can build something revolutionary with modest resources.\n\nThe future isn't one person per computer. It's computers that adapt to people, not the other way around. And unlike Microsoft's abandoned attempts, this approach actually works.",
      "created_at": "2025-07-17T17:28:04.095898+00:00"
    },
    {
      "uuid": "32d96211-e8b2-40bf-9a82-a687de5c01cd",
      "filename": "windows-power-tools-manifesto-old.md",
      "content": "# Windows 11 Power Tools: A Manifesto for Input Liberation and System Control\n\n## Executive Summary\n\nThis document outlines a revolutionary suite of tools designed to transform Windows 11 from a single-user, rigidly-controlled operating system into a flexible, multi-user, power-user paradise. Through three interconnected but independent components\u2014a Universal Input Router, an Advanced Window Manager, and a Process Priority Visualizer\u2014we liberate computing from decades-old paradigms.\n\nThe core philosophy: **Every assumption about how we interact with computers is just a historical accident waiting to be questioned.**\n\nMost remarkably, this software solution effectively transforms one physical computer into multiple independent workstations\u2014each with its own keyboard, mouse, and monitor(s)\u2014without virtualization overhead. A single powerful PC can serve an entire family, classroom, or office as if it were multiple separate computers.\n\n---\n\n## Table of Contents\n\n1. [Vision: Computing Unchained](#vision-computing-unchained)\n2. [Component 1: Universal Input Router](#component-1-universal-input-router)\n3. [Component 2: Advanced Window Manager](#component-2-advanced-window-manager)\n3. [Component 3: Process Priority Visualizer](#component-3-process-priority-visualizer)\n5. [Integration Philosophy](#integration-philosophy)\n6. [Revolutionary Use Cases](#revolutionary-use-cases)\n7. [Technical Feasibility](#technical-feasibility)\n\n---\n\n## Vision: Computing Unchained\n\n### The Problem Space\n\nModern operating systems trap us in assumptions from the 1980s:\n- One keyboard, one mouse, one user\n- Only Ctrl, Alt, Shift, and Win are \"modifiers\"\n- Input goes to one program at a time\n- Process priority is invisible and immutable\n- Window management is mouse-centric\n- Every program reinvents text editing\n\n### The Solution Space\n\nWe propose a radical reimagining where:\n- Any number of input devices serve any number of users on one machine\n- Every key can be a modifier, every rhythm a command\n- Input streams fork, merge, and transform freely\n- Process priority becomes visible and interactive\n- Navigation is modal, efficient, and consistent where possible\n- Common input patterns work across applications\n\n---\n\n## Component 1: Universal Input Router\n\n### Core Philosophy: Device-Aware Input Routing\n\nUsing Windows Raw Input API, we can identify specific devices and route their input to specific programs, regardless of window focus.\n\n```\nRaw Device Event \u2192 Router (where?) \u2192 Mapper (what?) \u2192 Target Program\n```\n\n### The Architecture\n\n```\nDevice ID: 0x1234, ScanCode: 0x24, State: Down\n              \u2193\n         [ROUTER RULES]\n         \u251c\u2192 Active Window (traditional behavior)\n         \u251c\u2192 Specific Program (device-locked)\n         \u2514\u2192 Multiple Programs (multicast)\n              \u2193\n    [MAPPER SELECTION PER TARGET]\n    \u251c\u2192 Raw Events (passthrough)\n    \u251c\u2192 Key Remapping (simple substitution)\n    \u251c\u2192 Macro Expansion (complex sequences)\n    \u251c\u2192 Context-Aware (program-specific)\n    \u2514\u2192 Modal States (vim-like layers)\n```\n\n### Technical Implementation\n\n**Raw Input Registration**\n```cpp\nRAWINPUTDEVICE rid[2];\nrid[0].usUsagePage = 0x01;  // Generic Desktop\nrid[0].usUsage = 0x06;      // Keyboard\nrid[0].dwFlags = RIDEV_INPUTSINK | RIDEV_DEVNOTIFY;\nrid[0].hwndTarget = hWnd;\n\nRegisterRawInputDevices(rid, 2, sizeof(RAWINPUTDEVICE));\n```\n\n**Device Identification**\nEach USB device has a unique hardware ID that persists across reboots:\n- VID/PID for USB devices\n- Instance path for differentiation\n- Bluetooth devices have persistent IDs\n\n### Input Transformation Pipeline\n\n1. **Capture**: Raw Input API provides hardware events\n2. **Route**: Determine target program(s) based on device\n3. **Transform**: Apply mapper rules\n4. **Inject**: Use appropriate method:\n   - SendInput() for global injection\n   - PostMessage() for specific windows\n   - Hooks for intercepting existing input\n\n### Key Innovations\n\n#### 1. Per-Device Routing\n```yaml\nrouting_rules:\n  keyboard_1: \n    target: \"code.exe\"\n    exclusive: true\n  \n  keyboard_2:\n    target: \"active_window\"\n    \n  foot_pedals:\n    targets: [\"spotify.exe\", \"obs.exe\"]\n    mode: \"multicast\"\n```\n\n#### 2. Temporal Commands\nInstead of chord combinations, use time-based patterns:\n- Double-tap backslash within 100ms = command mode\n- Hold for different durations = different commands\n- Rhythmic patterns = complex macros\n\n#### 3. Language-Aware Input\nThe router can maintain multiple keyboard layouts simultaneously:\n```\nPhysical Key \u2192 Router \u2192 Multiple Interpretations\n                 \u2193\n           Program receives:\n           - US Layout: 'a'\n           - Greek: '\u03b1'  \n           - Cyrillic: '\u0430'\n```\n\n### Realistic Mapper Types\n\n1. **Simple Remapping**: Key A \u2192 Key B\n2. **Macro Player**: Key sequence \u2192 Complex output\n3. **Layer System**: Modal states like vim\n4. **Auto-Switcher**: Context-based layout switching\n5. **Rate Limiter**: Gaming-specific anti-cheat compliance\n\n---\n\n## Component 2: Advanced Window Manager\n\n### Core Concept: Enhanced Window Control\n\nInstead of replacing Windows' window manager (technically infeasible), we enhance it with:\n- Keyboard-driven window manipulation\n- Multi-monitor workspace management\n- Device-specific focus rules\n- Tiling window layouts\n\n### Implementation Approach\n\n**Window Manipulation via Windows API**\n```cpp\n// Move and resize windows programmatically\nSetWindowPos(hwnd, HWND_TOP, x, y, width, height, SWP_SHOWWINDOW);\n\n// Monitor enumeration for multi-monitor support\nEnumDisplayMonitors(NULL, NULL, MonitorEnumProc, 0);\n\n// Window focus management\nSetForegroundWindow(hwnd);\nSetFocus(hwnd);\n```\n\n### Key Features\n\n#### 1. Keyboard-Driven Navigation\n- Win+Number: Quick window switching\n- Win+Arrows: Directional focus movement\n- Custom hotkeys for window manipulation\n\n#### 2. Virtual Desktops Enhancement\nExtend Windows 11's virtual desktops:\n- Per-monitor desktop switching\n- Device-specific desktop affinity\n- Programmatic desktop management\n\n#### 3. Tiling Layouts\n```cpp\n// Automatic window tiling\nvoid TileWindows(HMONITOR monitor, TilingMode mode) {\n    RECT monitorRect = GetMonitorWorkArea(monitor);\n    vector<HWND> windows = GetWindowsOnMonitor(monitor);\n    \n    switch(mode) {\n        case TILE_VERTICAL:\n            // Divide monitor vertically\n            break;\n        case TILE_GRID:\n            // Create grid layout\n            break;\n    }\n}\n```\n\n### Multi-User Window Management\n\n**Monitor-Based User Zones**\n```cpp\nstruct UserZone {\n    vector<HMONITOR> monitors;\n    RECT boundingBox;\n    bool confineMouse;\n    \n    void ConfineCursor() {\n        ClipCursor(&boundingBox);\n    }\n};\n```\n\n**Focus Isolation**\nEach device can have independent focus:\n- Keyboard 1 types into Window A\n- Keyboard 2 types into Window B\n- Both simultaneously, no focus switching\n\n---\n\n## Component 3: Process Priority Visualizer\n\n### Realistic Scope: Visualization, Not Control\n\nWindows kernel scheduling is not modifiable from userspace. Instead, we:\n- Visualize current process priorities\n- Show CPU usage and blocking relationships\n- Allow priority adjustment within Windows limits\n- Provide visual feedback for system behavior\n\n### Implementation\n\n**Process Information Gathering**\n```cpp\n// Enumerate processes\nHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n// Get process priority\nHANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);\nDWORD priority = GetPriorityClass(hProcess);\n\n// Monitor CPU usage via Performance Counters\nPDH_HQUERY query;\nPdhOpenQuery(NULL, 0, &query);\nPdhAddCounter(query, L\"\\\\Process(*)\\\\% Processor Time\", 0, &counter);\n```\n\n**Visualization Components**\n- D3.js or similar for interactive graphs\n- Node = Process\n- Edge = Resource dependency\n- Size = CPU usage\n- Color = Priority class\n\n**User Interaction**\n- Drag to request priority change\n- Windows may or may not honor it\n- Visual feedback shows actual vs requested\n\n---\n\n## Integration Philosophy\n\n### Modular Architecture\n\nEach component operates independently:\n- Router works without window manager\n- Window manager works without router\n- Visualizer is purely observational\n\n### Communication via Windows Messages\n\nComponents communicate through:\n- Named pipes for IPC\n- Custom Windows messages\n- Shared memory for performance\n- Registry for configuration\n\n### No Kernel Drivers Required\n\nEverything runs in userspace:\n- Raw Input API for device access\n- Windows API for window control\n- Performance counters for monitoring\n- No admin rights needed for basic features\n\n---\n\n## Revolutionary Use Cases\n\n### The Multi-User Desktop\n```\nFamily Computer Setup:\n- Parent: Keyboard/Mouse 1 \u2192 Monitors 1-2\n- Teen: Keyboard/Mouse 2 \u2192 Monitor 3\n- Child: Keyboard/Mouse 3 \u2192 Monitor 4\n\nEach has:\n- Independent focus\n- Confined mouse movement\n- Personal workspace\n```\n\n### The Streaming Setup\n```\nGaming Devices \u2192 Game (never loses focus)\nSecondary Keyboard \u2192 OBS/Chat\nFoot Pedals \u2192 Universal hotkeys\nEye Tracker \u2192 Window selection\n```\n\n### The Accessibility Solution\n- Limited mobility: Foot pedals for common actions\n- Repetitive strain: Distribute input across devices\n- Visual impairment: Consistent keyboard navigation\n\n### The Power User Workspace\n- Primary keyboard: Current focus window\n- Macro pad: Always controls specific apps\n- Gaming mouse: Extra buttons for window management\n- Touchpad: Gesture-based desktop switching\n\n---\n\n## Technical Feasibility\n\n### What's Possible\n\u2705 Device-specific input routing via Raw Input API  \n\u2705 Window manipulation and tiling via Windows API  \n\u2705 Process priority visualization  \n\u2705 Multi-monitor management  \n\u2705 Virtual desktop enhancement  \n\u2705 Keyboard-driven navigation  \n\u2705 Basic multi-user scenarios  \n\n### What's Challenging\n\u26a0\ufe0f True focus isolation (requires hooks)  \n\u26a0\ufe0f Universal text navigation (limited by application)  \n\u26a0\ufe0f Complete mouse confinement (security restrictions)  \n\u26a0\ufe0f System-wide vim mode (needs per-app implementation)  \n\n### What's Not Possible\n\u274c Kernel-level scheduling changes  \n\u274c Bypassing Windows security model  \n\u274c Universal font layer interception  \n\u274c Complete input isolation between users  \n\n---\n\n## Conclusion\n\nThis system transforms Windows from a single-user paradigm to a flexible, multi-device, potentially multi-user environment. By working within Windows' constraints while pushing its capabilities, we can achieve:\n\n- Device-aware input routing\n- Enhanced window management\n- Visual system monitoring\n- Improved accessibility\n- Novel interaction patterns\n\nThe future isn't about replacing Windows\u2014it's about unlocking its hidden potential.\n\n---\n\n*\"The best tools don't fight the system; they transcend its limitations.\"*",
      "created_at": "2025-07-17T17:29:16.938636+00:00"
    },
    {
      "uuid": "8b90f98a-fd0a-432e-b0dc-45b1c750da39",
      "filename": "windows-input-mapper-api.md",
      "content": "# Windows Input Domain Mapper API - Technical Design Document\n\n## Executive Summary\n\nThis document describes a revolutionary input handling system for Windows that separates physical input from semantic actions, enabling true multi-user computing, modal interfaces, and user-owned input preferences. By replacing Explorer.exe with a custom shell that captures raw input, we can implement sophisticated input transformation without kernel modifications.\n\n## Core Architecture\n\n### System Overview\n\n```\n[Physical Input] \u2192 [Raw Input API] \u2192 [Device Router] \u2192 [Mapper Pipeline] \u2192 [Semantic Events] \u2192 [Applications]\n                                           \u2193\n                                    [Domain Manager]\n```\n\n### Key Components\n\n1. **Explorer2.exe** - Custom Windows shell replacing Explorer\n2. **Raw Input Capture** - Lowest-level input interception\n3. **Device Router** - Routes input to appropriate domains\n4. **Mapper Pipeline** - Stackable, composable input transformers\n5. **Semantic Event System** - Abstract actions instead of keys\n6. **Legacy Bridge** - Compatibility with existing applications\n\n## The Mapper API\n\n### Core Interfaces\n\n```csharp\n// Base mapper interface - all mappers implement this\npublic interface IInputMapper {\n    // Mapper metadata\n    string Name { get; }\n    string Description { get; }\n    MapperPriority Priority { get; }\n    \n    // Configuration\n    void Configure(IMapperConfig config);\n    bool CanHandleDevice(InputDevice device);\n    bool IsActiveInContext(ApplicationContext context);\n    \n    // Core processing\n    InputResult ProcessInput(InputEvent input, MapperContext context);\n}\n\n// Input flows through the pipeline\npublic class InputEvent {\n    public InputDevice Device { get; set; }\n    public InputType Type { get; set; }  // Key, Mouse, etc.\n    public uint RawCode { get; set; }\n    public InputState State { get; set; } // Down, Up, Hold\n    public long Timestamp { get; set; }\n    public bool Consumed { get; set; }\n    public object RawData { get; set; }\n}\n\n// Mappers return transformation results\npublic class InputResult {\n    public enum ResultAction {\n        PassThrough,      // Continue to next mapper\n        Transform,        // Replace with new event(s)\n        Consume,          // Stop processing\n        Buffer,           // Hold for temporal processing\n        Fork              // Send to multiple paths\n    }\n    \n    public ResultAction Action { get; set; }\n    public List<OutputEvent> TransformedEvents { get; set; }\n    public TimeSpan? BufferDuration { get; set; }\n}\n\n// Output can be semantic or legacy\npublic abstract class OutputEvent {\n    public long Timestamp { get; set; }\n    public InputDomain TargetDomain { get; set; }\n}\n\npublic class SemanticEvent : OutputEvent {\n    public Enum ActionType { get; set; }  // FPSActions.MOVE_FORWARD\n    public float Magnitude { get; set; }   // For analog inputs\n    public Dictionary<string, object> Metadata { get; set; }\n}\n\npublic class LegacyEvent : OutputEvent {\n    public uint VirtualKey { get; set; }\n    public uint ScanCode { get; set; }\n    public bool Extended { get; set; }\n}\n```\n\n### Mapper Pipeline\n\n```csharp\npublic class MapperPipeline {\n    private List<IInputMapper> mappers = new();\n    private TemporalBuffer temporalBuffer = new();\n    \n    public void RegisterMapper(IInputMapper mapper) {\n        mappers.Add(mapper);\n        mappers.Sort((a, b) => a.Priority.CompareTo(b.Priority));\n    }\n    \n    public async Task ProcessInput(InputEvent input) {\n        var context = BuildContext(input);\n        \n        foreach (var mapper in mappers) {\n            if (!mapper.IsActiveInContext(context)) continue;\n            if (!mapper.CanHandleDevice(input.Device)) continue;\n            \n            var result = mapper.ProcessInput(input, context);\n            \n            switch (result.Action) {\n                case ResultAction.PassThrough:\n                    continue;\n                    \n                case ResultAction.Transform:\n                    // Replace input with transformed events\n                    foreach (var output in result.TransformedEvents) {\n                        await RouteOutput(output);\n                    }\n                    return;\n                    \n                case ResultAction.Consume:\n                    return;\n                    \n                case ResultAction.Buffer:\n                    temporalBuffer.Add(input, result.BufferDuration);\n                    return;\n                    \n                case ResultAction.Fork:\n                    // Send to multiple destinations\n                    var tasks = result.TransformedEvents\n                        .Select(e => RouteOutput(e));\n                    await Task.WhenAll(tasks);\n                    return;\n            }\n        }\n        \n        // No mapper handled it - send as legacy\n        await SendLegacyInput(input);\n    }\n}\n```\n\n## Mapper Types & Examples\n\n### 1. Modal Mapper (RTS Example)\n\n```csharp\npublic class RTSModalMapper : IInputMapper {\n    private enum Mode { Macro, Micro, Scouting }\n    private Mode currentMode = Mode.Macro;\n    \n    private Dictionary<Mode, Dictionary<uint, SemanticEvent>> mappings = new() {\n        [Mode.Macro] = new() {\n            [Keys.A] = new SemanticEvent { ActionType = RTSActions.SELECT_COMMAND_CENTER },\n            [Keys.S] = new SemanticEvent { ActionType = RTSActions.SELECT_BARRACKS },\n            [Keys.Num1] = new SemanticEvent { ActionType = RTSActions.BUILD_WORKER_QUEUE_5 }\n        },\n        [Mode.Micro] = new() {\n            [Keys.A] = new SemanticEvent { ActionType = RTSActions.ATTACK_MOVE },\n            [Keys.S] = new SemanticEvent { ActionType = RTSActions.STOP },\n        },\n        [Mode.Scouting] = new() {\n            [Keys.A] = new SemanticEvent { ActionType = RTSActions.CAMERA_QUADRANT_A },\n            [Keys.Q] = new SemanticEvent { ActionType = RTSActions.CYCLE_ENEMY_BUILDINGS }\n        }\n    };\n    \n    public InputResult ProcessInput(InputEvent input, MapperContext context) {\n        // Mode switching keys are global\n        if (input.Type == InputType.KeyDown) {\n            switch (input.RawCode) {\n                case Keys.Q:\n                    currentMode = Mode.Macro;\n                    ShowModeOverlay(\"MACRO MODE\");\n                    return new InputResult { Action = ResultAction.Consume };\n                case Keys.W:\n                    currentMode = Mode.Micro;\n                    ShowModeOverlay(\"MICRO MODE\");\n                    return new InputResult { Action = ResultAction.Consume };\n                case Keys.E:\n                    currentMode = Mode.Scouting;\n                    ShowModeOverlay(\"SCOUTING MODE\");\n                    return new InputResult { Action = ResultAction.Consume };\n            }\n        }\n        \n        // Check if current mode has mapping for this key\n        if (mappings[currentMode].TryGetValue(input.RawCode, out var semantic)) {\n            return new InputResult {\n                Action = ResultAction.Transform,\n                TransformedEvents = new() { semantic }\n            };\n        }\n        \n        return new InputResult { Action = ResultAction.PassThrough };\n    }\n}\n```\n\n### 2. Temporal Mapper (Vim-style)\n\n```csharp\npublic class TemporalMapper : IInputMapper {\n    private List<TemporalPattern> patterns = new();\n    private List<InputEvent> buffer = new();\n    private DateTime bufferStart;\n    \n    public TemporalMapper() {\n        // Register patterns\n        patterns.Add(new TemporalPattern {\n            Sequence = \"jk\",\n            MaxInterval = TimeSpan.FromMilliseconds(50),\n            Output = new SemanticEvent { ActionType = GlobalActions.ESCAPE }\n        });\n        \n        patterns.Add(new TemporalPattern {\n            Sequence = \"\\\\\\\\\",\n            MaxInterval = TimeSpan.FromMilliseconds(100),\n            Output = new SemanticEvent { ActionType = GlobalActions.COMMAND_PALETTE }\n        });\n    }\n    \n    public InputResult ProcessInput(InputEvent input, MapperContext context) {\n        if (input.Type != InputType.KeyDown) \n            return new InputResult { Action = ResultAction.PassThrough };\n        \n        // Add to buffer\n        buffer.Add(input);\n        if (buffer.Count == 1) bufferStart = DateTime.Now;\n        \n        // Check all patterns\n        foreach (var pattern in patterns) {\n            if (MatchesPattern(buffer, pattern)) {\n                buffer.Clear();\n                return new InputResult {\n                    Action = ResultAction.Transform,\n                    TransformedEvents = new() { pattern.Output }\n                };\n            }\n        }\n        \n        // If buffer is too old or too long, flush it\n        if (DateTime.Now - bufferStart > TimeSpan.FromMilliseconds(100) \n            || buffer.Count > 5) {\n            \n            var events = buffer.Select(b => new LegacyEvent {\n                VirtualKey = b.RawCode,\n                Timestamp = b.Timestamp\n            }).ToList();\n            \n            buffer.Clear();\n            \n            return new InputResult {\n                Action = ResultAction.Transform,\n                TransformedEvents = events.Cast<OutputEvent>().ToList()\n            };\n        }\n        \n        // Still building pattern - buffer it\n        return new InputResult {\n            Action = ResultAction.Buffer,\n            BufferDuration = TimeSpan.FromMilliseconds(50)\n        };\n    }\n}\n```\n\n### 3. Semantic Mapper (FPS)\n\n```csharp\npublic class FPSSemanticMapper : IInputMapper {\n    private UserPreferences prefs;\n    \n    public FPSSemanticMapper(UserPreferences prefs) {\n        this.prefs = prefs;\n        // User configured: \"I like ESDF for movement\"\n    }\n    \n    public InputResult ProcessInput(InputEvent input, MapperContext context) {\n        // Only active in FPS games\n        if (!context.Application.Categories.Contains(\"FPS\")) \n            return new InputResult { Action = ResultAction.PassThrough };\n        \n        var action = prefs.GetFPSAction(input.RawCode);\n        if (action != null) {\n            return new InputResult {\n                Action = ResultAction.Transform,\n                TransformedEvents = new() {\n                    new SemanticEvent { \n                        ActionType = action,\n                        Magnitude = 1.0f \n                    }\n                }\n            };\n        }\n        \n        return new InputResult { Action = ResultAction.PassThrough };\n    }\n}\n```\n\n### 4. Device-Specific Mapper\n\n```csharp\npublic class GamingMouseMapper : IInputMapper {\n    private MouseProfile profile;\n    \n    public bool CanHandleDevice(InputDevice device) {\n        return device.Type == DeviceType.Mouse \n            && device.VID == \"046D\"  // Logitech\n            && device.IsGamingDevice;\n    }\n    \n    public InputResult ProcessInput(InputEvent input, MapperContext context) {\n        // Gaming mouse in FPS mode - no smoothing, raw input\n        if (context.Domain.IsGaming) {\n            return new InputResult {\n                Action = ResultAction.Transform,\n                TransformedEvents = new() {\n                    new LegacyEvent {\n                        VirtualKey = input.RawCode,\n                        Metadata = { [\"RawInput\"] = true }\n                    }\n                }\n            };\n        }\n        \n        // Office mode - add smoothing\n        return new InputResult {\n            Action = ResultAction.Transform,\n            TransformedEvents = new() {\n                ApplyMouseSmoothing(input)\n            }\n        };\n    }\n}\n```\n\n## Context System\n\n```csharp\npublic class MapperContext {\n    public ApplicationContext Application { get; set; }\n    public InputDomain Domain { get; set; }\n    public WindowInfo ActiveWindow { get; set; }\n    public UserProfile User { get; set; }\n    public List<InputEvent> RecentInputs { get; set; }\n    public SystemState SystemState { get; set; }\n}\n\npublic class ApplicationContext {\n    public string ProcessName { get; set; }\n    public string WindowTitle { get; set; }\n    public List<string> Categories { get; set; } // \"FPS\", \"RTS\", \"TextEditor\"\n    public bool IsFullscreen { get; set; }\n    public bool HasFocus { get; set; }\n    public Rectangle WindowBounds { get; set; }\n}\n```\n\n## Device Management\n\n```csharp\npublic class DeviceManager {\n    private Dictionary<string, DeviceProfile> knownDevices = new();\n    \n    public async Task<DeviceProfile> OnDeviceConnected(InputDevice device) {\n        var fingerprint = await GenerateFingerprint(device);\n        \n        if (knownDevices.TryGetValue(fingerprint, out var profile)) {\n            return profile;\n        }\n        \n        // New device - interactive setup\n        var profile = await DeviceSetupWizard.Run(device);\n        knownDevices[fingerprint] = profile;\n        return profile;\n    }\n    \n    private async Task<string> GenerateFingerprint(InputDevice device) {\n        // Combine static and behavioral characteristics\n        var static_id = $\"{device.VID}:{device.PID}:{device.Serial}\";\n        var behavioral = await CaptureDeviceBehavior(device);\n        return Hash(static_id + behavioral);\n    }\n}\n\npublic class DeviceSetupWizard {\n    public static async Task<DeviceProfile> Run(InputDevice device) {\n        var dialog = new SetupDialog();\n        \n        dialog.Show($\"New {device.Type} detected! Let's set it up:\");\n        \n        // Step 1: Who uses it?\n        var user = await dialog.SelectUser();\n        \n        // Step 2: What for?\n        var purposes = await dialog.SelectPurposes(new[] {\n            \"Gaming\", \"Work\", \"General\", \"Creative\"\n        });\n        \n        // Step 3: Test it\n        dialog.Show(\"Move/click around to learn your style...\");\n        var behavior = await CaptureUsagePattern(device, TimeSpan.FromSeconds(5));\n        \n        // Step 4: Assign to domain\n        var domain = await dialog.SelectOrCreateDomain();\n        \n        return new DeviceProfile {\n            Device = device,\n            User = user,\n            Purposes = purposes,\n            BehaviorFingerprint = behavior,\n            AssignedDomain = domain,\n            Nickname = await dialog.GetNickname($\"{user.Name}'s {device.Type}\")\n        };\n    }\n}\n```\n\n## Semantic Action Registry\n\n```csharp\n// Applications register their semantic needs\npublic interface ISemanticApplication {\n    void RegisterActions(SemanticRegistry registry);\n    void OnSemanticAction(SemanticEvent action);\n}\n\n// Standard semantic categories\npublic enum FPSActions {\n    MOVE_FORWARD, MOVE_BACK, MOVE_LEFT, MOVE_RIGHT,\n    JUMP, CROUCH, SPRINT, WALK,\n    PRIMARY_FIRE, SECONDARY_FIRE, RELOAD, MELEE,\n    INTERACT, INVENTORY, MAP, SCOREBOARD\n}\n\npublic enum RTSActions {\n    // Unit Control\n    SELECT, ADD_TO_SELECTION, DESELECT,\n    MOVE, ATTACK_MOVE, PATROL, HOLD_POSITION,\n    \n    // Building\n    BUILD_WORKER, BUILD_SUPPLY, BUILD_BARRACKS,\n    \n    // Camera\n    CAMERA_LOCATION_1, CAMERA_SAVE_1,\n    CAMERA_FOLLOW_UNIT, CAMERA_CENTER_ON_SELECTION,\n    \n    // Economy  \n    SELECT_ALL_WORKERS, RETURN_TO_WORK,\n    \n    // Combat\n    FOCUS_FIRE, SPREAD_FORMATION, RETREAT\n}\n\npublic enum TextEditorActions {\n    // Navigation\n    CURSOR_UP, CURSOR_DOWN, CURSOR_LEFT, CURSOR_RIGHT,\n    WORD_LEFT, WORD_RIGHT, LINE_START, LINE_END,\n    PAGE_UP, PAGE_DOWN, FILE_START, FILE_END,\n    \n    // Editing\n    DELETE_CHAR, DELETE_WORD, DELETE_LINE,\n    COPY, CUT, PASTE, UNDO, REDO,\n    \n    // Vim-specific\n    NORMAL_MODE, INSERT_MODE, VISUAL_MODE,\n    COMMAND_MODE, REPLACE_MODE\n}\n\npublic enum GlobalActions {\n    ESCAPE, ENTER, TAB, COMMAND_PALETTE,\n    SWITCH_DOMAIN, SWITCH_MAPPER_MODE,\n    SYSTEM_MENU, TASK_SWITCH\n}\n```\n\n## Legacy Application Support\n\n```csharp\npublic class LegacyBridge {\n    private readonly Dictionary<string, LegacyProfile> appProfiles = new();\n    \n    public LegacyBridge() {\n        // Pre-configured profiles for popular apps\n        appProfiles[\"CallOfDuty.exe\"] = new LegacyProfile {\n            ExpectedLayout = KeyLayout.WASD,\n            SemanticMappings = new() {\n                [FPSActions.MOVE_FORWARD] = Keys.W,\n                [FPSActions.MOVE_LEFT] = Keys.A,\n                [FPSActions.MOVE_BACK] = Keys.S,\n                [FPSActions.MOVE_RIGHT] = Keys.D\n            }\n        };\n    }\n    \n    public async Task TranslateSemanticToLegacy(\n        SemanticEvent semantic, \n        ApplicationContext app) \n    {\n        if (!appProfiles.TryGetValue(app.ProcessName, out var profile)) {\n            profile = await InferProfileFromApp(app);\n        }\n        \n        if (profile.SemanticMappings.TryGetValue(\n            semantic.ActionType, \n            out var legacyKey)) \n        {\n            await SendInput(new INPUT {\n                type = INPUT_KEYBOARD,\n                ki = new KEYBDINPUT {\n                    wVk = legacyKey,\n                    dwFlags = 0\n                }\n            });\n        }\n    }\n}\n```\n\n## Implementation Roadmap\n\n### Phase 1: Core Shell (Week 1)\n- Replace Explorer.exe\n- Capture Raw Input\n- Basic device routing\n- Simple key remapping\n\n### Phase 2: Mapper Pipeline (Week 2-3)\n- Implement mapper interface\n- Build pipeline processor  \n- Add temporal mapper\n- Create configuration UI\n\n### Phase 3: Semantic Layer (Week 4-5)\n- Define semantic actions\n- Build legacy bridge\n- Create FPS/RTS mappers\n- Profile popular applications\n\n### Phase 4: Advanced Features (Week 6-8)\n- Modal mapping system\n- Device fingerprinting\n- Multi-domain support\n- Performance optimization\n\n## Performance Considerations\n\n```csharp\npublic class PerformanceOptimizer {\n    // Direct passthrough for performance-critical paths\n    public bool ShouldBypassPipeline(InputEvent input, MapperContext context) {\n        return context.Domain.IsGaming \n            && context.Application.IsFullscreen\n            && input.Device.Type == DeviceType.GamingMouse\n            && !context.User.HasActiveMappers;\n    }\n    \n    // Pre-compiled mapping tables for hot paths\n    private unsafe void DirectRemap(uint* input, uint* output) {\n        // Generated assembly for zero-overhead remapping\n        *output = remapTable[*input];\n    }\n}\n```\n\n## Security & Isolation\n\n```csharp\npublic class DomainSecurity {\n    public bool CanInputCrossDomains(\n        InputDomain source, \n        InputDomain target,\n        InputEvent input) \n    {\n        // Prevent keylogging across security boundaries\n        if (target.SecurityLevel > source.SecurityLevel) {\n            return false;\n        }\n        \n        // Allow explicit domain switching\n        if (input.IsSystemKeyCombination()) {\n            return true;\n        }\n        \n        return source.AllowsCrossDomainInput;\n    }\n}\n```\n\n## Conclusion\n\nThis mapper API design enables:\n\n1. **True input abstraction** - Semantic actions instead of hardware keys\n2. **Modal interfaces** - Context-aware input transformation\n3. **User ownership** - Preferences that follow users across applications\n4. **Backward compatibility** - Works with all existing Windows software\n5. **Extensibility** - Anyone can write custom mappers\n6. **Performance** - Near-zero overhead for critical paths\n\nBy implementing this as a shell replacement reading from Raw Input API, we avoid kernel modifications while achieving revolutionary input handling capabilities. The system transforms Windows from a single-user OS with fixed input assumptions into a flexible, multi-user platform where users truly own their input experience.",
      "created_at": "2025-07-17T17:28:03.816780+00:00"
    }
  ],
  "prompt_template": "We are making several tools that make the windows 11 experience better. \n\n1) Window manager. Panel/Taskbar and navigation. We'll aim for the option to control everything easily with keyboards. \n\n2) Windows multi-seat input router: device-specific keyboard/mouse mapping, per-application profiles, enabling multiple users on one PC with separate peripherals. \n\n3) Concurrency control to make \"single program utility\" efficient. Drown out the many tasks that are always running in easy ways.\n\n\n1.a) Vim like navigation across programs. Including such things as '%' jump between symmetric structure open and end. Or things like macros. Or temporal leader commands e.g. \"\\+_{below 100ms}+\\\" (that is \\ followed by \\ against within short time. below 100 or maybe 50ms or smt) opens a command list (e.g. to switch keyboard layouts or whatever else. It allows for many more \"input keys\" by allowing for temporal combining of keys into commands or macros or symbols). (See project file: )\n1.b) Tiling manager in i3 like fashion; with vim-like as default setting. (See project file: )\n\n2.a) We intercept device i/o in this manner: \"Raw I/O interrupt (Device ID: XXX) -> low-level mapper redirects to programs reading input from that I/O device -> runs through its selected device mapper (if none set chooses system default) -> i/o event is registered in the program at the Hook level.\"\n2.b) Devices bound to particular programs. Or particular mappers. Or both.\n\"\"\"Because I usually use two keyboards. Or might use say 3 more bluetooth keyboards. And I want to have mappers making their function different.\nSay route the keyboard input from a bluetooth keyboard and mouse to only programs on one of my 10 monitors connected to my computer.\nAnd such things. Allowing my computer to be used by multiple persons at the same time.\"\"\"\n\n3.a) We want to be able to drown out everything for \"task with priority complete || timeout timer elapsed\".\n3.b) We want to be able to easily move a graph of utility priority around to have the nodes/computations we care about receive massive preference in context switching and time granted to compute."
}